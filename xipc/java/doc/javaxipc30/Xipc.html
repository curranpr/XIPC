<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Wed Mar 30 17:17:40 EST 2005 -->
<TITLE>
Envoy Technologies XIPC Java Client API: Class  Xipc
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Xipc.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../javaxipc30/XintRef.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../javaxipc30/XipcErr.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Xipc.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javaxipc30</FONT>
<BR>
Class  Xipc</H2>
<PRE>
java.lang.Object
  |
  +--<B>javaxipc30.Xipc</B>
</PRE>
<HR>
<DL>
<DT>public class <B>Xipc</B><DT>extends java.lang.Object</DL>

<P>
<P>The <TT>Xipc</TT> class represents a connection to an Xipc network instance.
 <!-- Copyright (C) Envoy Technologies Inc., 2001 -->
 <!-- Xipc 3.0 Java API Documentation -->
 The documentation for this class constitutes the bulk of the documentation for
 the <A HREF="package-summary.html">javaxipc30 package</A>, and
 closely parallels the Reference Manual for the Xipc version 3.0 C API.	This
 documentation mentions operations which are not yet implemented in the Java
 API, but which are relevant for Java applications that are sharing an Xipc
 instance with C or C++ applications.  See <A
 HREF="package-summary.html">javaxipc30 package</A> for further
 details.
 <P>Xipc operations, and the methods that perform them, are conceptually
 classified into four categories: SemSys, MemSys, QueSys and general Xipc
 operations.
 <P>The class Xipc includes methods for creating an Xipc connection object
 (Constructor), for controlling Xipc network instance logins (general Xipc
 methods), and for performing operations on semaphores (SemSys methods), message
 queues (QueSys methods) and shared memory segments (MemSys methods). These
 methods are documented below.
 <P>While much can be done with a single Xipc object, it is often useful, when
 working with multiple threads, to create mutiple Xipc objects.  Several Xipc
 methods have a <A HREF="XipcBlockingOption.html">blocking option parameter</A>,
 and may block while waiting for the operation performed by the method to
 complete. While blocked, the object is locked, and any other thread that
 invokes one of the objects methods (only it's synchronized methods) will block
 until the first operation completes. In this case, the second thread could have
 used a seperate Xipc object, and then would not need to wait while the other
 thread is blocked.
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/SidList.html"><CODE>SidList</CODE></A>, 
<A HREF="../javaxipc30/QidList.html"><CODE>QidList</CODE></A>, 
<A HREF="../javaxipc30/MidList.html"><CODE>MidList</CODE></A>, 
<A HREF="../javaxipc30/Section.html"><CODE>Section</CODE></A>, 
<A HREF="../javaxipc30/XintRef.html"><CODE>XintRef</CODE></A>, 
<A HREF="../javaxipc30/XipcErr.html"><CODE>XipcErr</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#COPYRIGHT">COPYRIGHT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copyright &copy; Envoy Technologies, 2001.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MAX_BLOCKOPTVAL">MAX_BLOCKOPTVAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MAX_FLAGGABLE_BLOCKOPTVAL">MAX_FLAGGABLE_BLOCKOPTVAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MAX_TIMEOUT">MAX_TIMEOUT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_ADD_R">MEM_ADD_R</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_ADD_W">MEM_ADD_W</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_ALL">MEM_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to MemLock.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_ANY">MEM_ANY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to MemLock.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_ATOMIC">MEM_ATOMIC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to MemLock.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_BLOCKEDLOCK">MEM_BLOCKEDLOCK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_BLOCKEDOWN">MEM_BLOCKEDOWN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_BLOCKEDREAD">MEM_BLOCKEDREAD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_BLOCKEDWRITE">MEM_BLOCKEDWRITE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_LEN_INFOLIST">MEM_LEN_INFOLIST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_LEN_MIDLIST">MEM_LEN_MIDLIST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_LEN_SECTION">MEM_LEN_SECTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_LEN_XIPCNAME">MEM_LEN_XIPCNAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum length of a MemSys segment name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_MAX_MIDLIST">MEM_MAX_MIDLIST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum number of Mids in a MidList (8).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_NA">MEM_NA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_NC">MEM_NC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_NOWAIT">MEM_NOWAIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to MemLock and MemRead.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_PRIVATE">MEM_PRIVATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name used to create a private memory segment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_RMV_R">MEM_RMV_R</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_RMV_W">MEM_RMV_W</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_RO">MEM_RO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_RW">MEM_RW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_LOCK_CODE">MEM_T_LOCK_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_POOL_HIGH_CODE">MEM_T_POOL_HIGH_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_POOL_LOW_CODE">MEM_T_POOL_LOW_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_READ_CODE">MEM_T_READ_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_SECTION_HIGH_CODE">MEM_T_SECTION_HIGH_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_SECTION_LOW_CODE">MEM_T_SECTION_LOW_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_UNLOCK_CODE">MEM_T_UNLOCK_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_USER_LOCK_CODE">MEM_T_USER_LOCK_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_USER_READ_CODE">MEM_T_USER_READ_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_USER_UNLOCK_CODE">MEM_T_USER_UNLOCK_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_USER_WRITE_CODE">MEM_T_USER_WRITE_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_WRITE_CODE">MEM_T_WRITE_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_TIMEOUT">MEM_TIMEOUT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_WAIT">MEM_WAIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to MemLock and MemRead.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_WO">MEM_WO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MSGHDR_DATASIZE">MSGHDR_DATASIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#OPT_FLAG_MASK">OPT_FLAG_MASK</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_BLOCKEDGET">QUE_BLOCKEDGET</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_BLOCKEDPUT">QUE_BLOCKEDPUT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_BLOCKEDWRITE">QUE_BLOCKEDWRITE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_BLOCKOPT_REPLACE">QUE_BLOCKOPT_REPLACE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_DUPLICATED">QUE_DUPLICATED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_LEN_INFOLIST">QUE_LEN_INFOLIST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_LEN_PATHNAME">QUE_LEN_PATHNAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_LEN_QIDITEM">QUE_LEN_QIDITEM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_LEN_QIDLIST">QUE_LEN_QIDLIST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_LEN_XIPCNAME">QUE_LEN_XIPCNAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum length of a QueSys queue name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_EA_CODE">QUE_M_EA_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_HP_CODE">QUE_M_HP_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_LA_CODE">QUE_M_LA_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_LP_CODE">QUE_M_LP_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PREQ_CODE">QUE_M_PREQ_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRGE_CODE">QUE_M_PRGE_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRGT_CODE">QUE_M_PRGT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRLE_CODE">QUE_M_PRLE_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRLT_CODE">QUE_M_PRLT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRNE_CODE">QUE_M_PRNE_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRRNG_CODE">QUE_M_PRRNG_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQEQ_CODE">QUE_M_SEQEQ_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQGE_CODE">QUE_M_SEQGE_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQGT_CODE">QUE_M_SEQGT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQLE_CODE">QUE_M_SEQLE_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQLT_CODE">QUE_M_SEQLT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_MAX_QIDLIST">QUE_MAX_QIDLIST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum number of Qids in a QidList (8).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_NOLIMIT">QUE_NOLIMIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to QueCreate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_NOREMOVE">QUE_NOREMOVE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_NOTREMOVED">QUE_NOTREMOVED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_NOWAIT">QUE_NOWAIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to QueReceive and QueSend.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_PRIO_NEXT">QUE_PRIO_NEXT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_PRIO_PREV">QUE_PRIO_PREV</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_PRIVATE">QUE_PRIVATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name used to create a private queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_ANY">QUE_Q_ANY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_EA">QUE_Q_EA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_EAQ">QUE_Q_EAQ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_HP">QUE_Q_HP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_HPQ">QUE_Q_HPQ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_LA">QUE_Q_LA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_LAQ">QUE_Q_LAQ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_LNQ">QUE_Q_LNQ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_LP">QUE_Q_LP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_LPQ">QUE_Q_LPQ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_Q_SHQ">QUE_Q_SHQ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A queue select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_REMOVED">QUE_REMOVED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_REPLACE_EA">QUE_REPLACE_EA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_REPLACE_HP">QUE_REPLACE_HP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_REPLACE_LA">QUE_REPLACE_LA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_REPLACE_LP">QUE_REPLACE_LP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_REPLICATE">QUE_REPLICATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_REPLICATED">QUE_REPLICATED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_RETPRIO">QUE_RETPRIO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_RETSEQ">QUE_RETSEQ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_SPOOL_OFF">QUE_SPOOL_OFF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_BYTES_HIGH_CODE">QUE_T_BYTES_HIGH_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_BYTES_LOW_CODE">QUE_T_BYTES_LOW_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_GET_CODE">QUE_T_GET_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_GET_PREQ_CODE">QUE_T_GET_PREQ_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_GET_PRGT_CODE">QUE_T_GET_PRGT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_GET_PRLT_CODE">QUE_T_GET_PRLT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_HEADER_HIGH_CODE">QUE_T_HEADER_HIGH_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_HEADER_LOW_CODE">QUE_T_HEADER_LOW_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_MSGS_HIGH_CODE">QUE_T_MSGS_HIGH_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_MSGS_LOW_CODE">QUE_T_MSGS_LOW_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_POOL_HIGH_CODE">QUE_T_POOL_HIGH_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_POOL_LOW_CODE">QUE_T_POOL_LOW_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_PUT_CODE">QUE_T_PUT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_PUT_PREQ_CODE">QUE_T_PUT_PREQ_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_PUT_PRGT_CODE">QUE_T_PUT_PRGT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_PUT_PRLT_CODE">QUE_T_PUT_PRLT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_USER_GET_CODE">QUE_T_USER_GET_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_USER_PUT_CODE">QUE_T_USER_PUT_CODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_TIME_NEXT">QUE_TIME_NEXT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_TIME_PREV">QUE_TIME_PREV</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_TIMEOUT">QUE_TIMEOUT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_WAIT">QUE_WAIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to QueReceive and QueSend.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_ALL">SEM_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to SemAcquire and SemWait.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_ANY">SEM_ANY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to SemAcquire and SemWait.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_ATOMIC">SEM_ATOMIC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to SemAcquire and SemWait.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_CLEAR">SEM_CLEAR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Paramater value for SemCreate, and part of SemWait blocking option parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_LEN_INFOLIST">SEM_LEN_INFOLIST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_LEN_SIDLIST">SEM_LEN_SIDLIST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_LEN_XIPCNAME">SEM_LEN_XIPCNAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum length of a SemSys semaphore name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_MAX_SIDLIST">SEM_MAX_SIDLIST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum number of Sids in a SidList (32).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_NOWAIT">SEM_NOWAIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to SemAcquire and SemWait.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_PRIVATE">SEM_PRIVATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Name used to create a private semaphore.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_SET">SEM_SET</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value for SemCreate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_TIMEOUT">SEM_TIMEOUT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_WAIT">SEM_WAIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to SemAcquire and SemWait.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#VERSION">VERSION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A String containing version information.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_BLOCKOPT_NOWAIT">XIPC_BLOCKOPT_NOWAIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_BLOCKOPT_REPLICATE">XIPC_BLOCKOPT_REPLICATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_BLOCKOPT_TIMEOUT">XIPC_BLOCKOPT_TIMEOUT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_BLOCKOPT_WAIT">XIPC_BLOCKOPT_WAIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_GETOPT_MAXTEXTSIZE">XIPC_GETOPT_MAXTEXTSIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter to XipcGetOpt for getting MAX_TEXT_SIZE system parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_LEN_NETNAME">XIPC_LEN_NETNAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maximum length of a network instance name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_LEN_PATHNAME">XIPC_LEN_PATHNAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_LEN_XIPCNAME">XIPC_LEN_XIPCNAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_LOGIN_SUPERUSER">XIPC_LOGIN_SUPERUSER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Super-user login name.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_PRIVATE">XIPC_PRIVATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPC_SETOPT_MAXTEXTSIZE">XIPC_SETOPT_MAXTEXTSIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter to XipcSetOpt for setting MAX_TEXT_SIZE system parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XIPCSERV_PORTNUM">XIPCSERV_PORTNUM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The port that Xipc is using on the host machine.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XNET_LEN_NETNAME">XNET_LEN_NETNAME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XNET_SPOOLOFF">XNET_SPOOLOFF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#Xipc()">Xipc</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The constructor for new Xipc objects.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#ClearBuf()">ClearBuf</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#getInt(byte[], int)">getInt</A></B>(byte[]&nbsp;b,
       int&nbsp;off)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_LOCK(int, int, int)">MEM_T_LOCK</A></B>(int&nbsp;Mid,
           int&nbsp;Offset,
           int&nbsp;Size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the shared memory area specified by <I>Mid</I>,
 <I>Offset</I> and <I>Size</I>
 (or any part of it) is locked.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_POOL_HIGH(int)">MEM_T_POOL_HIGH</A></B>(int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the allocated size of the shared memory pool becomes higher
 than <I>N</I> percent of its capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_POOL_LOW(int)">MEM_T_POOL_LOW</A></B>(int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the allocated size of the shared memory pool becomes lower
 than <I>N</I> percent of its capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_READ(int, int, int)">MEM_T_READ</A></B>(int&nbsp;Mid,
           int&nbsp;Offset,
           int&nbsp;Size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when data is read from the shared memory area specified by
 <I>Mid</I>, <I>Offset</I> and <I>Size</I>
 (or any part of it).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_SECTION_HIGH(int)">MEM_T_SECTION_HIGH</A></B>(int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the number of allocated sections becomes higher than
 <I>N</I> percent of the capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_SECTION_LOW(int)">MEM_T_SECTION_LOW</A></B>(int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the number of allocated sections becomes lower than <I>N</I>
 percent of the capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_UNLOCK(int, int, int)">MEM_T_UNLOCK</A></B>(int&nbsp;Mid,
             int&nbsp;Offset,
             int&nbsp;Size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the shared memory area specified by <I>Mid</I>,
 <I>Offset</I> and <I>Size</I>
 (or any part of it) is unlocked.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_USER_LOCK(int, int, int, int)">MEM_T_USER_LOCK</A></B>(int&nbsp;Mid,
                int&nbsp;Offset,
                int&nbsp;Size,
                int&nbsp;Uid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when user <I>Uid</I> locks the shared memory area specified by
 <I>Mid</I>, <I>Offset</I> and <I>Size</I> (or any part of it).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_USER_READ(int, int, int, int)">MEM_T_USER_READ</A></B>(int&nbsp;Mid,
                int&nbsp;Offset,
                int&nbsp;Size,
                int&nbsp;Uid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when user <I>Uid</I> reads data from the shared memory area
 specified by <I>Mid</I>, <I>Offset</I> and <I>Size</I> (or any part of it).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_USER_UNLOCK(int, int, int, int)">MEM_T_USER_UNLOCK</A></B>(int&nbsp;Mid,
                  int&nbsp;Offset,
                  int&nbsp;Size,
                  int&nbsp;Uid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when user <I>Uid</I> unlocks the shared memory area specified by
 <I>Mid</I>, <I>Offset</I> and <I>Size</I> (or any part of it).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_USER_WRITE(int, int, int, int)">MEM_T_USER_WRITE</A></B>(int&nbsp;Mid,
                 int&nbsp;Offset,
                 int&nbsp;Size,
                 int&nbsp;Uid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when user <I>Uid</I> writes data to the shared memory area
 specified by <I>Mid</I>, <I>Offset</I> and <I>Size</I> (or any part of it).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_T_WRITE(int, int, int)">MEM_T_WRITE</A></B>(int&nbsp;Mid,
            int&nbsp;Offset,
            int&nbsp;Size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when data is written into the shared memory area specified by
 <I>Mid</I>, <I>Offset</I> and <I>Size</I>
 (or any part of it).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MEM_TIMEOUT(int)">MEM_TIMEOUT</A></B>(int&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to MemLock and MemRead.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemAccess(java.lang.String)">MemAccess</A></B>(java.lang.String&nbsp;Name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Access an existing memory segment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemCreate(java.lang.String, int)">MemCreate</A></B>(java.lang.String&nbsp;Name,
          int&nbsp;Size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a New Memory Segment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemDelete(int)">MemDelete</A></B>(int&nbsp;Mid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete a Memory Segment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemDestroy(int)">MemDestroy</A></B>(int&nbsp;Mid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy a MemSys Memory Segment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemFreeze()">MemFreeze</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemInfoMem(int, javaxipc30.MemInfoMem)">MemInfoMem</A></B>(int&nbsp;mid,
           <A HREF="../javaxipc30/MemInfoMem.html">MemInfoMem</A>&nbsp;infoMem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemInfoSec(javaxipc30.Section, javaxipc30.MemInfoSec)">MemInfoSec</A></B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;section,
           <A HREF="../javaxipc30/MemInfoSec.html">MemInfoSec</A>&nbsp;infoSec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemInfoSys(javaxipc30.MemInfoSys)">MemInfoSys</A></B>(<A HREF="../javaxipc30/MemInfoSys.html">MemInfoSys</A>&nbsp;InfoSys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemInfoUser(int, javaxipc30.MemInfoUser)">MemInfoUser</A></B>(int&nbsp;Uid,
            <A HREF="../javaxipc30/MemInfoUser.html">MemInfoUser</A>&nbsp;InfoUser)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MidList.html">MidList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemListAdd(javaxipc30.MidList, javaxipc30.Section)">MemListAdd</A></B>(<A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;ml,
           <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;Section)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add to a list of memory sections.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MidList.html">MidList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemListBuild(javaxipc30.Section)">MemListBuild</A></B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;Section)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Build a reusable list of memory sections.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)">MemLock</A></B>(int&nbsp;LockType,
        <A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;MidList,
        <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;retSec,
        int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lock Memory Section(s).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemRead(int, int, int, byte[], int)">MemRead</A></B>(int&nbsp;Mid,
        int&nbsp;Offset,
        int&nbsp;Length,
        byte[]&nbsp;Buffer,
        int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Read data from a memory segment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemSecDef(javaxipc30.Section)">MemSecDef</A></B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;section)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemSecOwn(int, javaxipc30.MidList, javaxipc30.Section, int)">MemSecOwn</A></B>(int&nbsp;ownType,
          <A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;midList,
          <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;retSec,
          int&nbsp;blockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemSecPriv(javaxipc30.Section, int, int)">MemSecPriv</A></B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;section,
           int&nbsp;ownerPrivilege,
           int&nbsp;otherPrivilege)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemSecRel(javaxipc30.MidList, javaxipc30.Section)">MemSecRel</A></B>(<A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;midList,
          <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;retSec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/Section.html">Section</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemSectionBuild(int, int, int)">MemSectionBuild</A></B>(int&nbsp;Mid,
                int&nbsp;Offset,
                int&nbsp;Size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new Section object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemSecUndef(javaxipc30.Section)">MemSecUndef</A></B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;section)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)">MemTrigger</A></B>(int&nbsp;Sid,
           <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A>&nbsp;trigSpec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define a MemSys Trigger.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemUnfreeze()">MemUnfreeze</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemUnlock(javaxipc30.MidList, javaxipc30.Section)">MemUnlock</A></B>(<A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;MidList,
          <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;retSec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unlock memory section(s).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)">MemUntrigger</A></B>(int&nbsp;Sid,
             <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A>&nbsp;trigSpec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undefine a MemSys Trigger.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemWrite(int, int, int, byte[], int)">MemWrite</A></B>(int&nbsp;Mid,
         int&nbsp;Offset,
         int&nbsp;Length,
         byte[]&nbsp;Buffer,
         int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write data from a buffer into a memory segment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#MemWrite(int, int, int, byte, int)">MemWrite</A></B>(int&nbsp;Mid,
         int&nbsp;Offset,
         int&nbsp;Length,
         byte&nbsp;fillbyte,
         int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fill part of a memory segment with a given byte value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#putArr(byte[], byte[], int, int)">putArr</A></B>(byte[]&nbsp;src,
       byte[]&nbsp;dest,
       int&nbsp;destOffset,
       int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#putArr(byte[], int, byte[], int, int)">putArr</A></B>(byte[]&nbsp;src,
       int&nbsp;srcOffset,
       byte[]&nbsp;dest,
       int&nbsp;destOffset,
       int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#putInt(int, byte[], int)">putInt</A></B>(int&nbsp;I,
       byte[]&nbsp;buf,
       int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#putList(javaxipc30.MidList, byte[], int)">putList</A></B>(<A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;src,
        byte[]&nbsp;dest,
        int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#putList(javaxipc30.QidList, byte[], int)">putList</A></B>(<A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;src,
        byte[]&nbsp;dest,
        int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#putList(javaxipc30.SidList, byte[], int)">putList</A></B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;src,
        byte[]&nbsp;dest,
        int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>(package private) static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#putString(java.lang.String, int, byte[], int)">putString</A></B>(java.lang.String&nbsp;str,
          int&nbsp;len,
          byte[]&nbsp;destBuffer,
          int&nbsp;destOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_EA(int)">QUE_M_EA</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_HP(int)">QUE_M_HP</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_LA(int)">QUE_M_LA</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_LP(int)">QUE_M_LP</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PREQ(int, int)">QUE_M_PREQ</A></B>(int&nbsp;Qid,
           int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRGE(int, int)">QUE_M_PRGE</A></B>(int&nbsp;Qid,
           int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRGT(int, int)">QUE_M_PRGT</A></B>(int&nbsp;Qid,
           int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRLE(int, int)">QUE_M_PRLE</A></B>(int&nbsp;Qid,
           int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRLT(int, int)">QUE_M_PRLT</A></B>(int&nbsp;Qid,
           int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRNE(int, int)">QUE_M_PRNE</A></B>(int&nbsp;Qid,
           int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_PRRNG(int, int, int)">QUE_M_PRRNG</A></B>(int&nbsp;Qid,
            int&nbsp;n,
            int&nbsp;m)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQEQ(int, int)">QUE_M_SEQEQ</A></B>(int&nbsp;Qid,
            int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQGE(int, int)">QUE_M_SEQGE</A></B>(int&nbsp;Qid,
            int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQGT(int, int)">QUE_M_SEQGT</A></B>(int&nbsp;Qid,
            int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQLE(int, int)">QUE_M_SEQLE</A></B>(int&nbsp;Qid,
            int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_M_SEQLT(int, int)">QUE_M_SEQLT</A></B>(int&nbsp;Qid,
            int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A QueReceive Message Select Code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_BYTES_HIGH(int, int)">QUE_T_BYTES_HIGH</A></B>(int&nbsp;Qid,
                 int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when number of bytes written to queue <I>Qid</I>
 becomes higher than <I>N</I> percent of the queues byte capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_BYTES_LOW(int, int)">QUE_T_BYTES_LOW</A></B>(int&nbsp;Qid,
                int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when number of bytes written to queue <I>Qid</I>
 becomes lower than <I>N</I> percent of the queues byte capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_GET_PREQ(int, int)">QUE_T_GET_PREQ</A></B>(int&nbsp;Qid,
               int&nbsp;Prio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message of priority <I>P</I> is removed from queue
 <I>Qid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_GET_PRGT(int, int)">QUE_T_GET_PRGT</A></B>(int&nbsp;Qid,
               int&nbsp;Prio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message of priority greater than <I>P</I>
 is removed from queue <I>Qid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_GET_PRLT(int, int)">QUE_T_GET_PRLT</A></B>(int&nbsp;Qid,
               int&nbsp;Prio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message of priority less than <I>P</I>
 is removed from queue <I>Qid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_GET(int)">QUE_T_GET</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message is removed from queue <I>Qid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_HEADER_HIGH(int)">QUE_T_HEADER_HIGH</A></B>(int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the number of allocated message headers becomes higher than
 <I>N</I> percent of the instances capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_HEADER_LOW(int)">QUE_T_HEADER_LOW</A></B>(int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the number of allocated message headers becomes lower than
 <I>N</I> percent of the instances capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_MSGS_HIGH(int, int)">QUE_T_MSGS_HIGH</A></B>(int&nbsp;Qid,
                int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when number of messages written to queue <I>Qid</I>
 becomes higher than <I>N</I> percent of queues message capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_MSGS_LOW(int, int)">QUE_T_MSGS_LOW</A></B>(int&nbsp;Qid,
               int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when number of messages written to queue <I>Qid</I>
 becomes lower than <I>N</I> percent of queues message capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_POOL_HIGH(int)">QUE_T_POOL_HIGH</A></B>(int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the allocated size of the message text pool becomes higher
 than <I>N</I> percent of the instances capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_POOL_LOW(int)">QUE_T_POOL_LOW</A></B>(int&nbsp;N)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when the allocated size of the message text pool becomes lower
 than <I>N</I> percent of the instances capacity.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_PUT_PREQ(int, int)">QUE_T_PUT_PREQ</A></B>(int&nbsp;Qid,
               int&nbsp;Prio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message of priority <I>P</I> is put onto queue <I>Qid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_PUT_PRGT(int, int)">QUE_T_PUT_PRGT</A></B>(int&nbsp;Qid,
               int&nbsp;Prio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message of priority greater than <I>P</I>
 is put onto queue <I>Qid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_PUT_PRLT(int, int)">QUE_T_PUT_PRLT</A></B>(int&nbsp;Qid,
               int&nbsp;Prio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message of priority less than <I>P</I>
 is put onto queue <I>Qid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_PUT(int)">QUE_T_PUT</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message is put onto queue <I>Qid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_USER_GET(int, int)">QUE_T_USER_GET</A></B>(int&nbsp;Qid,
               int&nbsp;Uid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message is removed from queue <I>Qid</I>
 by user <I>Uid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_T_USER_PUT(int, int)">QUE_T_USER_PUT</A></B>(int&nbsp;Qid,
               int&nbsp;Uid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger event when a message is put onto queue <I>Qid</I>
 by user <I>Uid</I>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_TIMEOUT(int)">QUE_TIMEOUT</A></B>(int&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to QueReceive and QueSend.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QUE_TRUNCATE(int)">QUE_TRUNCATE</A></B>(int&nbsp;MsgLen)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to QueReceive.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueAccess(java.lang.String)">QueAccess</A></B>(java.lang.String&nbsp;Name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Access an existing queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueBrowse(javaxipc30.MsgHdr, int)">QueBrowse</A></B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
          int&nbsp;Direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueCopy(javaxipc30.MsgHdr, int, int, byte[])">QueCopy</A></B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
        int&nbsp;offset,
        int&nbsp;length,
        byte[]&nbsp;buffer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueCreate(java.lang.String, int, int)">QueCreate</A></B>(java.lang.String&nbsp;Name,
          int&nbsp;LimitMsgs,
          int&nbsp;LimitBytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueDelete(int)">QueDelete</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete a queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueDestroy(int)">QueDestroy</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy a queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueFreeze()">QueFreeze</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueGet(javaxipc30.MsgHdr, int, javaxipc30.QidList, javaxipc30.XintRef, javaxipc30.XintRef, int)">QueGet</A></B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
       int&nbsp;QueSelectCode,
       <A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;qidList,
       <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetPrio,
       <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetQid,
       int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueInfoQue(int, javaxipc30.QueInfoQue)">QueInfoQue</A></B>(int&nbsp;Qid,
           <A HREF="../javaxipc30/QueInfoQue.html">QueInfoQue</A>&nbsp;InfoQue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueInfoSys(javaxipc30.QueInfoSys)">QueInfoSys</A></B>(<A HREF="../javaxipc30/QueInfoSys.html">QueInfoSys</A>&nbsp;InfoSys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueInfoUser(int, javaxipc30.QueInfoUser)">QueInfoUser</A></B>(int&nbsp;Uid,
            <A HREF="../javaxipc30/QueInfoUser.html">QueInfoUser</A>&nbsp;InfoUser)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QidList.html">QidList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueListAdd(javaxipc30.QidList, int)">QueListAdd</A></B>(<A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;QidList,
           int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a Qid to an existing QidList.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QidList.html">QidList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueListAdd(javaxipc30.QidList, javaxipc30.MsgSelectQid)">QueListAdd</A></B>(<A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;QidList,
           <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A>&nbsp;MSQid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a Qid with a message select code to an existing QidList.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QidList.html">QidList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueListBuild(int)">QueListBuild</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Build a new QidList containing a single Qid.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/QidList.html">QidList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueListBuild(javaxipc30.MsgSelectQid)">QueListBuild</A></B>(<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A>&nbsp;MSQid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Build a new QidList containing a single Qid with message select code.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueMsgHdrDup(javaxipc30.MsgHdr, javaxipc30.MsgHdr)">QueMsgHdrDup</A></B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;existingMsgHdr,
             <A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;newMsgHdr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QuePurge(int)">QuePurge</A></B>(int&nbsp;Qid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QuePut(javaxipc30.MsgHdr, int, javaxipc30.QidList, int, javaxipc30.XintRef, int)">QuePut</A></B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
       int&nbsp;QueSelectCode,
       <A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;qidList,
       int&nbsp;Priority,
       <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetQid,
       int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueRead(javaxipc30.MsgHdr, byte[], int)">QueRead</A></B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
        byte[]&nbsp;MsgBuf,
        int&nbsp;MsgLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)">QueReceive</A></B>(int&nbsp;QueSelectCode,
           <A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;QidList,
           byte[]&nbsp;MsgBuf,
           int&nbsp;MsgLength,
           <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetPrio,
           <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetQid,
           int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Receive and read a message from a queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueRemove(javaxipc30.MsgHdr)">QueRemove</A></B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)">QueSend</A></B>(int&nbsp;QueSelectCode,
        <A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;QidList,
        byte[]&nbsp;MsgBuf,
        int&nbsp;MsgLength,
        int&nbsp;Priority,
        <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetQid,
        int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write and send a message to a queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueSpool(int, java.lang.String)">QueSpool</A></B>(int&nbsp;Qid,
         java.lang.String&nbsp;spoolFileName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)">QueTrigger</A></B>(int&nbsp;Sid,
           <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A>&nbsp;trigSpec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Define a QueSys Trigger.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueUnfreeze()">QueUnfreeze</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueUnget(javaxipc30.MsgHdr)">QueUnget</A></B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)">QueUntrigger</A></B>(int&nbsp;Sid,
             <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A>&nbsp;trigSpec)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Undefine a QueSys Trigger.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#QueWrite(javaxipc30.MsgHdr, byte[], int, int)">QueWrite</A></B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
         byte[]&nbsp;MsgBuf,
         int&nbsp;MsgLength,
         int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SEM_TIMEOUT(int)">SEM_TIMEOUT</A></B>(int&nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Parameter value to SemAcquire and SemWait.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemAccess(java.lang.String)">SemAccess</A></B>(java.lang.String&nbsp;Name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Access an existing semaphore.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)">SemAcquire</A></B>(int&nbsp;AcquireType,
           <A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
           <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid,
           int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acquire resource semaphores.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemCancel(javaxipc30.SidList, javaxipc30.XintRef)">SemCancel</A></B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
          <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Cancel blocked semaphore operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemClear(javaxipc30.SidList, javaxipc30.XintRef)">SemClear</A></B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
         <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clear event semaphores.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemCreate(java.lang.String, int)">SemCreate</A></B>(java.lang.String&nbsp;Name,
          int&nbsp;CreateValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new semaphore.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemDelete(int)">SemDelete</A></B>(int&nbsp;Sid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete a semaphore.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemDestroy(int)">SemDestroy</A></B>(int&nbsp;Sid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Destroy a semaphore.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemFreeze()">SemFreeze</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemInfoSem(int, javaxipc30.SemInfoSem)">SemInfoSem</A></B>(int&nbsp;Sid,
           <A HREF="../javaxipc30/SemInfoSem.html">SemInfoSem</A>&nbsp;InfoSem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemInfoSys(javaxipc30.SemInfoSys)">SemInfoSys</A></B>(<A HREF="../javaxipc30/SemInfoSys.html">SemInfoSys</A>&nbsp;InfoSys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemInfoUser(int, javaxipc30.SemInfoUser)">SemInfoUser</A></B>(int&nbsp;Uid,
            <A HREF="../javaxipc30/SemInfoUser.html">SemInfoUser</A>&nbsp;InfoUser)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/SidList.html">SidList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemListAdd(javaxipc30.SidList, int)">SemListAdd</A></B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
           int&nbsp;Sid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Add a Sid to an existing SidList.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../javaxipc30/SidList.html">SidList</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemListBuild(int)">SemListBuild</A></B>(int&nbsp;Sid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Build a new SidList containing a single Sid.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemRelease(javaxipc30.SidList, javaxipc30.XintRef)">SemRelease</A></B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
           <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Release resource semaphores.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemSet(javaxipc30.SidList, javaxipc30.XintRef)">SemSet</A></B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
       <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set event semaphores.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemUnfreeze()">SemUnfreeze</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)">SemWait</A></B>(int&nbsp;WaitType,
        <A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
        <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid,
        int&nbsp;BlockOpt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait on event semaphores.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XipcAbort(int)">XipcAbort</A></B>(int&nbsp;Uid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abort a user by forcing a logout.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XipcError(int)">XipcError</A></B>(int&nbsp;ErrCode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xipc error code translation function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XipcFreeze()">XipcFreeze</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XipcGetOpt(int)">XipcGetOpt</A></B>(int&nbsp;Option)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For obtaining the values of various parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XipcLogin(java.lang.String, java.lang.String)">XipcLogin</A></B>(java.lang.String&nbsp;instanceName,
          java.lang.String&nbsp;userName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log in to a network instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XipcLogout()">XipcLogout</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Log out of a network instance.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XipcSetOpt(int, int)">XipcSetOpt</A></B>(int&nbsp;Option,
           int&nbsp;Value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For changing the values of various parameters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../javaxipc30/Xipc.html#XipcUnfreeze()">XipcUnfreeze</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><clinit>, clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="VERSION"><!-- --></A><H3>
VERSION</H3>
<PRE>
public static final java.lang.String <B>VERSION</B></PRE>
<DL>
<DD>A String containing version information.</DL>
<HR>

<A NAME="COPYRIGHT"><!-- --></A><H3>
COPYRIGHT</H3>
<PRE>
public static final java.lang.String <B>COPYRIGHT</B></PRE>
<DL>
<DD>Copyright &copy; Envoy Technologies, 2001.</DL>
<HR>

<A NAME="XIPCSERV_PORTNUM"><!-- --></A><H3>
XIPCSERV_PORTNUM</H3>
<PRE>
public static int <B>XIPCSERV_PORTNUM</B></PRE>
<DL>
<DD>The port that Xipc is using on the host machine.
 The default value is 4001.</DL>
<HR>

<A NAME="XIPC_SETOPT_MAXTEXTSIZE"><!-- --></A><H3>
XIPC_SETOPT_MAXTEXTSIZE</H3>
<PRE>
public static final int <B>XIPC_SETOPT_MAXTEXTSIZE</B></PRE>
<DL>
<DD>Parameter to XipcSetOpt for setting MAX_TEXT_SIZE system parameter.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#XipcSetOpt(int, int)"><CODE>XipcSetOpt(int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="XIPC_GETOPT_MAXTEXTSIZE"><!-- --></A><H3>
XIPC_GETOPT_MAXTEXTSIZE</H3>
<PRE>
public static final int <B>XIPC_GETOPT_MAXTEXTSIZE</B></PRE>
<DL>
<DD>Parameter to XipcGetOpt for getting MAX_TEXT_SIZE system parameter.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#XipcGetOpt(int)"><CODE>XipcGetOpt(int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="XIPC_LEN_XIPCNAME"><!-- --></A><H3>
XIPC_LEN_XIPCNAME</H3>
<PRE>
static final int <B>XIPC_LEN_XIPCNAME</B></PRE>
<DL>
</DL>
<HR>

<A NAME="XIPC_LEN_NETNAME"><!-- --></A><H3>
XIPC_LEN_NETNAME</H3>
<PRE>
public static final int <B>XIPC_LEN_NETNAME</B></PRE>
<DL>
<DD>Maximum length of a network instance name.</DL>
<HR>

<A NAME="XNET_LEN_NETNAME"><!-- --></A><H3>
XNET_LEN_NETNAME</H3>
<PRE>
static final int <B>XNET_LEN_NETNAME</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_LEN_XIPCNAME"><!-- --></A><H3>
MEM_LEN_XIPCNAME</H3>
<PRE>
public static final int <B>MEM_LEN_XIPCNAME</B></PRE>
<DL>
<DD>Maximum length of a MemSys segment name.</DL>
<HR>

<A NAME="QUE_LEN_XIPCNAME"><!-- --></A><H3>
QUE_LEN_XIPCNAME</H3>
<PRE>
public static final int <B>QUE_LEN_XIPCNAME</B></PRE>
<DL>
<DD>Maximum length of a QueSys queue name.</DL>
<HR>

<A NAME="SEM_LEN_XIPCNAME"><!-- --></A><H3>
SEM_LEN_XIPCNAME</H3>
<PRE>
public static final int <B>SEM_LEN_XIPCNAME</B></PRE>
<DL>
<DD>Maximum length of a SemSys semaphore name.</DL>
<HR>

<A NAME="XIPC_LEN_PATHNAME"><!-- --></A><H3>
XIPC_LEN_PATHNAME</H3>
<PRE>
static final int <B>XIPC_LEN_PATHNAME</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_LEN_PATHNAME"><!-- --></A><H3>
QUE_LEN_PATHNAME</H3>
<PRE>
public static final int <B>QUE_LEN_PATHNAME</B></PRE>
<DL>
</DL>
<HR>

<A NAME="XIPC_LOGIN_SUPERUSER"><!-- --></A><H3>
XIPC_LOGIN_SUPERUSER</H3>
<PRE>
public static final java.lang.String <B>XIPC_LOGIN_SUPERUSER</B></PRE>
<DL>
<DD>Super-user login name.
 Used to log in to a possibly corrupt instance as a super-user.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#XipcLogin(java.lang.String, java.lang.String)"><CODE>XipcLogin(java.lang.String, java.lang.String)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="XIPC_PRIVATE"><!-- --></A><H3>
XIPC_PRIVATE</H3>
<PRE>
static final java.lang.String <B>XIPC_PRIVATE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="SEM_PRIVATE"><!-- --></A><H3>
SEM_PRIVATE</H3>
<PRE>
public static final java.lang.String <B>SEM_PRIVATE</B></PRE>
<DL>
<DD>Name used to create a private semaphore.
 May be used as a non-unique semaphore name.
 When used as a semaphore name, the semaphore may not be accessed with SemAccess.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#SemAccess(java.lang.String)"><CODE>SemAccess(java.lang.String)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemCreate(java.lang.String, int)"><CODE>SemCreate(java.lang.String, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_PRIVATE"><!-- --></A><H3>
QUE_PRIVATE</H3>
<PRE>
public static final java.lang.String <B>QUE_PRIVATE</B></PRE>
<DL>
<DD>Name used to create a private queue.
 May be used as a non-unique queue name.
 When used as a queue name, the queue may not be accessed with QueAccess.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueAccess(java.lang.String)"><CODE>QueAccess(java.lang.String)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueCreate(java.lang.String, int, int)"><CODE>QueCreate(java.lang.String, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_PRIVATE"><!-- --></A><H3>
MEM_PRIVATE</H3>
<PRE>
public static final java.lang.String <B>MEM_PRIVATE</B></PRE>
<DL>
<DD>Name used to create a private memory segment.
 May be used as a non-unique memory segment name.
 When used as a memory segment name, the segment may not be accessed with
 MemAccess.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemAccess(java.lang.String)"><CODE>MemAccess(java.lang.String)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemCreate(java.lang.String, int)"><CODE>MemCreate(java.lang.String, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="XNET_SPOOLOFF"><!-- --></A><H3>
XNET_SPOOLOFF</H3>
<PRE>
static final java.lang.String <B>XNET_SPOOLOFF</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_SPOOL_OFF"><!-- --></A><H3>
QUE_SPOOL_OFF</H3>
<PRE>
public static final java.lang.String <B>QUE_SPOOL_OFF</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_MAX_QIDLIST"><!-- --></A><H3>
QUE_MAX_QIDLIST</H3>
<PRE>
public static final int <B>QUE_MAX_QIDLIST</B></PRE>
<DL>
<DD>Maximum number of Qids in a QidList (8).<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/QidList.html"><CODE>QidList</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueListBuild(int)"><CODE>QueListBuild(int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueListAdd(javaxipc30.QidList, int)"><CODE>QueListAdd(javaxipc30.QidList, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="SEM_MAX_SIDLIST"><!-- --></A><H3>
SEM_MAX_SIDLIST</H3>
<PRE>
public static final int <B>SEM_MAX_SIDLIST</B></PRE>
<DL>
<DD>Maximum number of Sids in a SidList (32).<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/SidList.html"><CODE>SidList</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemListBuild(int)"><CODE>SemListBuild(int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemListAdd(javaxipc30.SidList, int)"><CODE>SemListAdd(javaxipc30.SidList, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_MAX_MIDLIST"><!-- --></A><H3>
MEM_MAX_MIDLIST</H3>
<PRE>
public static final int <B>MEM_MAX_MIDLIST</B></PRE>
<DL>
<DD>Maximum number of Mids in a MidList (8).<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/MidList.html"><CODE>MidList</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemListBuild(javaxipc30.Section)"><CODE>MemListBuild(javaxipc30.Section)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemListAdd(javaxipc30.MidList, javaxipc30.Section)"><CODE>MemListAdd(javaxipc30.MidList, javaxipc30.Section)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_LEN_QIDITEM"><!-- --></A><H3>
QUE_LEN_QIDITEM</H3>
<PRE>
static final int <B>QUE_LEN_QIDITEM</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_LEN_QIDLIST"><!-- --></A><H3>
QUE_LEN_QIDLIST</H3>
<PRE>
static final int <B>QUE_LEN_QIDLIST</B></PRE>
<DL>
</DL>
<HR>

<A NAME="SEM_LEN_SIDLIST"><!-- --></A><H3>
SEM_LEN_SIDLIST</H3>
<PRE>
static final int <B>SEM_LEN_SIDLIST</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_LEN_MIDLIST"><!-- --></A><H3>
MEM_LEN_MIDLIST</H3>
<PRE>
static final int <B>MEM_LEN_MIDLIST</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_LEN_SECTION"><!-- --></A><H3>
MEM_LEN_SECTION</H3>
<PRE>
static final int <B>MEM_LEN_SECTION</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MSGHDR_DATASIZE"><!-- --></A><H3>
MSGHDR_DATASIZE</H3>
<PRE>
public static final int <B>MSGHDR_DATASIZE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_LEN_INFOLIST"><!-- --></A><H3>
QUE_LEN_INFOLIST</H3>
<PRE>
public static final int <B>QUE_LEN_INFOLIST</B></PRE>
<DL>
</DL>
<HR>

<A NAME="SEM_LEN_INFOLIST"><!-- --></A><H3>
SEM_LEN_INFOLIST</H3>
<PRE>
public static final int <B>SEM_LEN_INFOLIST</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_LEN_INFOLIST"><!-- --></A><H3>
MEM_LEN_INFOLIST</H3>
<PRE>
public static final int <B>MEM_LEN_INFOLIST</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_Q_HP"><!-- --></A><H3>
QUE_Q_HP</H3>
<PRE>
public static final int <B>QUE_Q_HP</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the queue with the highest priority candidate
 message.
 For message retrieval only.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_LP"><!-- --></A><H3>
QUE_Q_LP</H3>
<PRE>
public static final int <B>QUE_Q_LP</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the queue with the lowest priority candidate
 message.
 For message retrieval only.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_EA"><!-- --></A><H3>
QUE_Q_EA</H3>
<PRE>
public static final int <B>QUE_Q_EA</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the queue with the earliest arrived candidate
 message.
 For message retrieval only.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_LA"><!-- --></A><H3>
QUE_Q_LA</H3>
<PRE>
public static final int <B>QUE_Q_LA</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the queue with the latest arrived candidate
 message.
 For message retrieval only.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_HPQ"><!-- --></A><H3>
QUE_Q_HPQ</H3>
<PRE>
public static final int <B>QUE_Q_HPQ</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the queue with the highest priority message.
 For message retrieval or dispatch.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_LPQ"><!-- --></A><H3>
QUE_Q_LPQ</H3>
<PRE>
public static final int <B>QUE_Q_LPQ</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the queue with the lowest priority message.
 For message retrieval or dispatch.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_EAQ"><!-- --></A><H3>
QUE_Q_EAQ</H3>
<PRE>
public static final int <B>QUE_Q_EAQ</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the queue with the earliest arrived message.
 For message retrieval or dispatch.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_LAQ"><!-- --></A><H3>
QUE_Q_LAQ</H3>
<PRE>
public static final int <B>QUE_Q_LAQ</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the queue with the latest arrived message.
 For message retrieval or dispatch.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_SHQ"><!-- --></A><H3>
QUE_Q_SHQ</H3>
<PRE>
public static final int <B>QUE_Q_SHQ</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the shortest queue.
 For message retrieval or dispatch.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_LNQ"><!-- --></A><H3>
QUE_Q_LNQ</H3>
<PRE>
public static final int <B>QUE_Q_LNQ</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the longest queue.
 For message retrieval or dispatch.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_Q_ANY"><!-- --></A><H3>
QUE_Q_ANY</H3>
<PRE>
public static final int <B>QUE_Q_ANY</B></PRE>
<DL>
<DD>A queue select code.
 Queue select code for selecting the queue with the first candidate message for
 retrieval, or the first non-full queue for dispatch.
 For message retrieval or dispatch.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_NOLIMIT"><!-- --></A><H3>
QUE_NOLIMIT</H3>
<PRE>
public static final int <B>QUE_NOLIMIT</B></PRE>
<DL>
<DD>Parameter value to QueCreate.
 Specifies to QueCreate that there is to be no limit on the number of messages
 or number of bytes of a message queue.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueCreate(java.lang.String, int, int)"><CODE>QueCreate(java.lang.String, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_HP_CODE"><!-- --></A><H3>
QUE_M_HP_CODE</H3>
<PRE>
public static final int <B>QUE_M_HP_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_LP_CODE"><!-- --></A><H3>
QUE_M_LP_CODE</H3>
<PRE>
public static final int <B>QUE_M_LP_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_EA_CODE"><!-- --></A><H3>
QUE_M_EA_CODE</H3>
<PRE>
public static final int <B>QUE_M_EA_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_LA_CODE"><!-- --></A><H3>
QUE_M_LA_CODE</H3>
<PRE>
public static final int <B>QUE_M_LA_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_PREQ_CODE"><!-- --></A><H3>
QUE_M_PREQ_CODE</H3>
<PRE>
public static final int <B>QUE_M_PREQ_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_PRNE_CODE"><!-- --></A><H3>
QUE_M_PRNE_CODE</H3>
<PRE>
public static final int <B>QUE_M_PRNE_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_PRGT_CODE"><!-- --></A><H3>
QUE_M_PRGT_CODE</H3>
<PRE>
public static final int <B>QUE_M_PRGT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_PRGE_CODE"><!-- --></A><H3>
QUE_M_PRGE_CODE</H3>
<PRE>
public static final int <B>QUE_M_PRGE_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_PRLT_CODE"><!-- --></A><H3>
QUE_M_PRLT_CODE</H3>
<PRE>
public static final int <B>QUE_M_PRLT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_PRLE_CODE"><!-- --></A><H3>
QUE_M_PRLE_CODE</H3>
<PRE>
public static final int <B>QUE_M_PRLE_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_PRRNG_CODE"><!-- --></A><H3>
QUE_M_PRRNG_CODE</H3>
<PRE>
public static final int <B>QUE_M_PRRNG_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_SEQEQ_CODE"><!-- --></A><H3>
QUE_M_SEQEQ_CODE</H3>
<PRE>
public static final int <B>QUE_M_SEQEQ_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_SEQGT_CODE"><!-- --></A><H3>
QUE_M_SEQGT_CODE</H3>
<PRE>
public static final int <B>QUE_M_SEQGT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_SEQGE_CODE"><!-- --></A><H3>
QUE_M_SEQGE_CODE</H3>
<PRE>
public static final int <B>QUE_M_SEQGE_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_SEQLT_CODE"><!-- --></A><H3>
QUE_M_SEQLT_CODE</H3>
<PRE>
public static final int <B>QUE_M_SEQLT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_M_SEQLE_CODE"><!-- --></A><H3>
QUE_M_SEQLE_CODE</H3>
<PRE>
public static final int <B>QUE_M_SEQLE_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="SEM_ATOMIC"><!-- --></A><H3>
SEM_ATOMIC</H3>
<PRE>
public static final int <B>SEM_ATOMIC</B></PRE>
<DL>
<DD>Parameter value to SemAcquire and SemWait.
 If the <I>AcquireType</I> parameter of SemAcquire equals SEM_ATOMIC, the
 request is not considered satisfied until all the semaphores in <I>SidList</I>
 are available and then acquired in a single atomic operation. Individual
 semaphores in <I>SidList</I>
 are not accumulated as they become available.
 If the <I>WaitType</I> parameter to SemWait equals SEM_ATOMIC, the request is
 not considered satisfied until all the semaphores in <I>SidList</I> are in the
 set state at one time. Semaphore states are noted as they become set until the
 entire <I>SidList</I>
 has been set. If a semaphore that was noted to be set changes its state to
 clear before the wait is satisfied, the change will be noted and will prevent
 the wait from being satisfied.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="SEM_ALL"><!-- --></A><H3>
SEM_ALL</H3>
<PRE>
public static final int <B>SEM_ALL</B></PRE>
<DL>
<DD>Parameter value to SemAcquire and SemWait.
 If the <I>AcquireType</I> parameter of SemAcquire equals SEM_ALL, the request
 is not considered satisfied until all the semaphores in <I>SidList</I> have
 been acquired. Semaphores are accumulated as they become available until the
 entire <I>SidList</I>
 has been acquired.
 If the <I>WaitType</I> parameter of SemWait equals SEM_ALL, the request is not
 considered satisfied until all the semaphores in <I>SidList</I> have been in
 the set state at least once since the beginning of the wait. Semaphore states
 are noted as they become set until the entire <I>SidList</I> has been set. If a
 semaphore that was noted to be set changes its state to clear before the wait
 is satisfied, the change will not affect the satisfaction of the wait.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="SEM_ANY"><!-- --></A><H3>
SEM_ANY</H3>
<PRE>
public static final int <B>SEM_ANY</B></PRE>
<DL>
<DD>Parameter value to SemAcquire and SemWait.
 If the <I>AcquireType</I> parameter of SemAcquire equals SEM_ANY, the request
 is considered satisfied when any one of the semaphores in <I>SidList</I> has
 been acquired.
 If the <I>WaitType</I> parameter of SemWait equals SEM_ANY, the request is
 considered satisfied when any one of the semaphores in <I>SidList</I> is in the
 set state.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_ATOMIC"><!-- --></A><H3>
MEM_ATOMIC</H3>
<PRE>
public static final int <B>MEM_ATOMIC</B></PRE>
<DL>
<DD>Parameter value to MemLock.
 If the <I>LockType</I> to MemLock equals MEM_ATOMIC, the request is not
 considered satisfied until all the memory sections in <I>MidList</I> are
 available and then locked in a single atomic operation. Individual memory
 sections in <I>MidList</I>
 are not locked as they become available.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)"><CODE>MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_ALL"><!-- --></A><H3>
MEM_ALL</H3>
<PRE>
public static final int <B>MEM_ALL</B></PRE>
<DL>
<DD>Parameter value to MemLock.
 If the <I>LockType</I> parameter to MemLock equals MEM_ALL, the request is not
 considered satisfied until all the memory sections in <I>MidList</I> have been
 locked. Memory sections are locked as they become available until all the
 sections in <I>MidList</I> have been locked.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)"><CODE>MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_ANY"><!-- --></A><H3>
MEM_ANY</H3>
<PRE>
public static final int <B>MEM_ANY</B></PRE>
<DL>
<DD>Parameter value to MemLock.
 If the <I>LockType</I> parameter to MemLock equals MEM_ANY, the request is
 considered satisfied when any one of the memory sections in <I>MidList</I> has
 been locked.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)"><CODE>MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="SEM_WAIT"><!-- --></A><H3>
SEM_WAIT</H3>
<PRE>
public static final int <B>SEM_WAIT</B></PRE>
<DL>
<DD>Parameter value to SemAcquire and SemWait.
 If the request specified in the method call cannot be satisfied, the thread
 that called the method is blocked until the request is completed.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SEM_TIMEOUT"><CODE>SEM_TIMEOUT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_WAIT"><!-- --></A><H3>
QUE_WAIT</H3>
<PRE>
public static final int <B>QUE_WAIT</B></PRE>
<DL>
<DD>Parameter value to QueReceive and QueSend.
 If the request specified in the method call cannot be satisfied, the thread
 that called the method is blocked until the request is completed.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QUE_TIMEOUT"><CODE>QUE_TIMEOUT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_WAIT"><!-- --></A><H3>
MEM_WAIT</H3>
<PRE>
public static final int <B>MEM_WAIT</B></PRE>
<DL>
<DD>Parameter value to MemLock and MemRead.
 If the request specified in the method call cannot be satisfied, the thread
 that called the method is blocked until the request is completed.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)"><CODE>MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemRead(int, int, int, byte[], int)"><CODE>MemRead(int, int, int, byte[], int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MEM_TIMEOUT"><CODE>MEM_TIMEOUT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="SEM_NOWAIT"><!-- --></A><H3>
SEM_NOWAIT</H3>
<PRE>
public static final int <B>SEM_NOWAIT</B></PRE>
<DL>
<DD>Parameter value to SemAcquire and SemWait.
 If the request specified in the method call cannot be satisfied, the method
 returns immediately with return code XipcErr.SEM_ER_NOWAIT.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SEM_TIMEOUT"><CODE>SEM_TIMEOUT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_NOWAIT"><!-- --></A><H3>
QUE_NOWAIT</H3>
<PRE>
public static final int <B>QUE_NOWAIT</B></PRE>
<DL>
<DD>Parameter value to QueReceive and QueSend.
 If the request specified in the method call cannot be satisfied, the method
 returns immediately with return code XipcErr.QUE_ER_NOWAIT.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QUE_TIMEOUT"><CODE>QUE_TIMEOUT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_NOWAIT"><!-- --></A><H3>
MEM_NOWAIT</H3>
<PRE>
public static final int <B>MEM_NOWAIT</B></PRE>
<DL>
<DD>Parameter value to MemLock and MemRead.
 If the request specified in the method call cannot be satisfied, the method
 returns immediately with return code XipcErr.MEM_ER_NOWAIT.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)"><CODE>MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemRead(int, int, int, byte[], int)"><CODE>MemRead(int, int, int, byte[], int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MEM_TIMEOUT"><CODE>MEM_TIMEOUT</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_REPLACE_EA"><!-- --></A><H3>
QUE_REPLACE_EA</H3>
<PRE>
public static final int <B>QUE_REPLACE_EA</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_REPLACE_LA"><!-- --></A><H3>
QUE_REPLACE_LA</H3>
<PRE>
public static final int <B>QUE_REPLACE_LA</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_REPLACE_HP"><!-- --></A><H3>
QUE_REPLACE_HP</H3>
<PRE>
public static final int <B>QUE_REPLACE_HP</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_REPLACE_LP"><!-- --></A><H3>
QUE_REPLACE_LP</H3>
<PRE>
public static final int <B>QUE_REPLACE_LP</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_REPLICATE"><!-- --></A><H3>
QUE_REPLICATE</H3>
<PRE>
public static final int <B>QUE_REPLICATE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MAX_BLOCKOPTVAL"><!-- --></A><H3>
MAX_BLOCKOPTVAL</H3>
<PRE>
static final int <B>MAX_BLOCKOPTVAL</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MAX_FLAGGABLE_BLOCKOPTVAL"><!-- --></A><H3>
MAX_FLAGGABLE_BLOCKOPTVAL</H3>
<PRE>
static final int <B>MAX_FLAGGABLE_BLOCKOPTVAL</B></PRE>
<DL>
</DL>
<HR>

<A NAME="OPT_FLAG_MASK"><!-- --></A><H3>
OPT_FLAG_MASK</H3>
<PRE>
static final int <B>OPT_FLAG_MASK</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MAX_TIMEOUT"><!-- --></A><H3>
MAX_TIMEOUT</H3>
<PRE>
public static final int <B>MAX_TIMEOUT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_NOREMOVE"><!-- --></A><H3>
QUE_NOREMOVE</H3>
<PRE>
public static final int <B>QUE_NOREMOVE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_RETSEQ"><!-- --></A><H3>
QUE_RETSEQ</H3>
<PRE>
public static final int <B>QUE_RETSEQ</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_RETPRIO"><!-- --></A><H3>
QUE_RETPRIO</H3>
<PRE>
public static final int <B>QUE_RETPRIO</B></PRE>
<DL>
</DL>
<HR>

<A NAME="SEM_CLEAR"><!-- --></A><H3>
SEM_CLEAR</H3>
<PRE>
public static final int <B>SEM_CLEAR</B></PRE>
<DL>
<DD>Paramater value for SemCreate, and part of SemWait blocking option parameter.
 When passed as <I>CreateValue</I> parameter of SemCreate, an event semaphore
 will be created in a clear (not set) state.
 When combined, by bitwise or, with a SemWait blocking option, it causes SemWait
 to clear set semaphores as they are found to be set.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#SemCreate(java.lang.String, int)"><CODE>SemCreate(java.lang.String, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="SEM_SET"><!-- --></A><H3>
SEM_SET</H3>
<PRE>
public static final int <B>SEM_SET</B></PRE>
<DL>
<DD>Parameter value for SemCreate.
 When passed as <I>CreateValue</I> parameter of SemCreate, an event semaphore
 will be created in a set state.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#SemCreate(java.lang.String, int)"><CODE>SemCreate(java.lang.String, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="XIPC_BLOCKOPT_WAIT"><!-- --></A><H3>
XIPC_BLOCKOPT_WAIT</H3>
<PRE>
static final int <B>XIPC_BLOCKOPT_WAIT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="XIPC_BLOCKOPT_NOWAIT"><!-- --></A><H3>
XIPC_BLOCKOPT_NOWAIT</H3>
<PRE>
static final int <B>XIPC_BLOCKOPT_NOWAIT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="XIPC_BLOCKOPT_TIMEOUT"><!-- --></A><H3>
XIPC_BLOCKOPT_TIMEOUT</H3>
<PRE>
static final int <B>XIPC_BLOCKOPT_TIMEOUT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="XIPC_BLOCKOPT_REPLICATE"><!-- --></A><H3>
XIPC_BLOCKOPT_REPLICATE</H3>
<PRE>
static final int <B>XIPC_BLOCKOPT_REPLICATE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_BLOCKOPT_REPLACE"><!-- --></A><H3>
QUE_BLOCKOPT_REPLACE</H3>
<PRE>
static final int <B>QUE_BLOCKOPT_REPLACE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="SEM_TIMEOUT"><!-- --></A><H3>
SEM_TIMEOUT</H3>
<PRE>
static final int <B>SEM_TIMEOUT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_TIMEOUT"><!-- --></A><H3>
QUE_TIMEOUT</H3>
<PRE>
static final int <B>QUE_TIMEOUT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_TIMEOUT"><!-- --></A><H3>
MEM_TIMEOUT</H3>
<PRE>
static final int <B>MEM_TIMEOUT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_BLOCKEDWRITE"><!-- --></A><H3>
QUE_BLOCKEDWRITE</H3>
<PRE>
public static final int <B>QUE_BLOCKEDWRITE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_BLOCKEDPUT"><!-- --></A><H3>
QUE_BLOCKEDPUT</H3>
<PRE>
public static final int <B>QUE_BLOCKEDPUT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_BLOCKEDGET"><!-- --></A><H3>
QUE_BLOCKEDGET</H3>
<PRE>
public static final int <B>QUE_BLOCKEDGET</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_BLOCKEDWRITE"><!-- --></A><H3>
MEM_BLOCKEDWRITE</H3>
<PRE>
public static final int <B>MEM_BLOCKEDWRITE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_BLOCKEDREAD"><!-- --></A><H3>
MEM_BLOCKEDREAD</H3>
<PRE>
public static final int <B>MEM_BLOCKEDREAD</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_BLOCKEDOWN"><!-- --></A><H3>
MEM_BLOCKEDOWN</H3>
<PRE>
public static final int <B>MEM_BLOCKEDOWN</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_BLOCKEDLOCK"><!-- --></A><H3>
MEM_BLOCKEDLOCK</H3>
<PRE>
public static final int <B>MEM_BLOCKEDLOCK</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_REMOVED"><!-- --></A><H3>
QUE_REMOVED</H3>
<PRE>
public static final int <B>QUE_REMOVED</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_NOTREMOVED"><!-- --></A><H3>
QUE_NOTREMOVED</H3>
<PRE>
public static final int <B>QUE_NOTREMOVED</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_REPLICATED"><!-- --></A><H3>
QUE_REPLICATED</H3>
<PRE>
public static final int <B>QUE_REPLICATED</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_DUPLICATED"><!-- --></A><H3>
QUE_DUPLICATED</H3>
<PRE>
public static final int <B>QUE_DUPLICATED</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_PRIO_NEXT"><!-- --></A><H3>
QUE_PRIO_NEXT</H3>
<PRE>
public static final int <B>QUE_PRIO_NEXT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_PRIO_PREV"><!-- --></A><H3>
QUE_PRIO_PREV</H3>
<PRE>
public static final int <B>QUE_PRIO_PREV</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_TIME_NEXT"><!-- --></A><H3>
QUE_TIME_NEXT</H3>
<PRE>
public static final int <B>QUE_TIME_NEXT</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_TIME_PREV"><!-- --></A><H3>
QUE_TIME_PREV</H3>
<PRE>
public static final int <B>QUE_TIME_PREV</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_BYTES_HIGH_CODE"><!-- --></A><H3>
QUE_T_BYTES_HIGH_CODE</H3>
<PRE>
static final int <B>QUE_T_BYTES_HIGH_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_MSGS_HIGH_CODE"><!-- --></A><H3>
QUE_T_MSGS_HIGH_CODE</H3>
<PRE>
static final int <B>QUE_T_MSGS_HIGH_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_PUT_CODE"><!-- --></A><H3>
QUE_T_PUT_CODE</H3>
<PRE>
static final int <B>QUE_T_PUT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_PUT_PREQ_CODE"><!-- --></A><H3>
QUE_T_PUT_PREQ_CODE</H3>
<PRE>
static final int <B>QUE_T_PUT_PREQ_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_PUT_PRLT_CODE"><!-- --></A><H3>
QUE_T_PUT_PRLT_CODE</H3>
<PRE>
static final int <B>QUE_T_PUT_PRLT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_PUT_PRGT_CODE"><!-- --></A><H3>
QUE_T_PUT_PRGT_CODE</H3>
<PRE>
static final int <B>QUE_T_PUT_PRGT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_USER_PUT_CODE"><!-- --></A><H3>
QUE_T_USER_PUT_CODE</H3>
<PRE>
static final int <B>QUE_T_USER_PUT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_POOL_HIGH_CODE"><!-- --></A><H3>
QUE_T_POOL_HIGH_CODE</H3>
<PRE>
static final int <B>QUE_T_POOL_HIGH_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_HEADER_HIGH_CODE"><!-- --></A><H3>
QUE_T_HEADER_HIGH_CODE</H3>
<PRE>
static final int <B>QUE_T_HEADER_HIGH_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_BYTES_LOW_CODE"><!-- --></A><H3>
QUE_T_BYTES_LOW_CODE</H3>
<PRE>
static final int <B>QUE_T_BYTES_LOW_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_MSGS_LOW_CODE"><!-- --></A><H3>
QUE_T_MSGS_LOW_CODE</H3>
<PRE>
static final int <B>QUE_T_MSGS_LOW_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_GET_CODE"><!-- --></A><H3>
QUE_T_GET_CODE</H3>
<PRE>
static final int <B>QUE_T_GET_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_GET_PREQ_CODE"><!-- --></A><H3>
QUE_T_GET_PREQ_CODE</H3>
<PRE>
static final int <B>QUE_T_GET_PREQ_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_GET_PRLT_CODE"><!-- --></A><H3>
QUE_T_GET_PRLT_CODE</H3>
<PRE>
static final int <B>QUE_T_GET_PRLT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_GET_PRGT_CODE"><!-- --></A><H3>
QUE_T_GET_PRGT_CODE</H3>
<PRE>
static final int <B>QUE_T_GET_PRGT_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_USER_GET_CODE"><!-- --></A><H3>
QUE_T_USER_GET_CODE</H3>
<PRE>
static final int <B>QUE_T_USER_GET_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_POOL_LOW_CODE"><!-- --></A><H3>
QUE_T_POOL_LOW_CODE</H3>
<PRE>
static final int <B>QUE_T_POOL_LOW_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="QUE_T_HEADER_LOW_CODE"><!-- --></A><H3>
QUE_T_HEADER_LOW_CODE</H3>
<PRE>
static final int <B>QUE_T_HEADER_LOW_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_READ_CODE"><!-- --></A><H3>
MEM_T_READ_CODE</H3>
<PRE>
static final int <B>MEM_T_READ_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_WRITE_CODE"><!-- --></A><H3>
MEM_T_WRITE_CODE</H3>
<PRE>
static final int <B>MEM_T_WRITE_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_LOCK_CODE"><!-- --></A><H3>
MEM_T_LOCK_CODE</H3>
<PRE>
static final int <B>MEM_T_LOCK_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_UNLOCK_CODE"><!-- --></A><H3>
MEM_T_UNLOCK_CODE</H3>
<PRE>
static final int <B>MEM_T_UNLOCK_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_USER_READ_CODE"><!-- --></A><H3>
MEM_T_USER_READ_CODE</H3>
<PRE>
static final int <B>MEM_T_USER_READ_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_USER_WRITE_CODE"><!-- --></A><H3>
MEM_T_USER_WRITE_CODE</H3>
<PRE>
static final int <B>MEM_T_USER_WRITE_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_USER_LOCK_CODE"><!-- --></A><H3>
MEM_T_USER_LOCK_CODE</H3>
<PRE>
static final int <B>MEM_T_USER_LOCK_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_USER_UNLOCK_CODE"><!-- --></A><H3>
MEM_T_USER_UNLOCK_CODE</H3>
<PRE>
static final int <B>MEM_T_USER_UNLOCK_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_POOL_HIGH_CODE"><!-- --></A><H3>
MEM_T_POOL_HIGH_CODE</H3>
<PRE>
static final int <B>MEM_T_POOL_HIGH_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_SECTION_HIGH_CODE"><!-- --></A><H3>
MEM_T_SECTION_HIGH_CODE</H3>
<PRE>
static final int <B>MEM_T_SECTION_HIGH_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_POOL_LOW_CODE"><!-- --></A><H3>
MEM_T_POOL_LOW_CODE</H3>
<PRE>
static final int <B>MEM_T_POOL_LOW_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_T_SECTION_LOW_CODE"><!-- --></A><H3>
MEM_T_SECTION_LOW_CODE</H3>
<PRE>
static final int <B>MEM_T_SECTION_LOW_CODE</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_RW"><!-- --></A><H3>
MEM_RW</H3>
<PRE>
public static final int <B>MEM_RW</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_RO"><!-- --></A><H3>
MEM_RO</H3>
<PRE>
public static final int <B>MEM_RO</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_WO"><!-- --></A><H3>
MEM_WO</H3>
<PRE>
public static final int <B>MEM_WO</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_NA"><!-- --></A><H3>
MEM_NA</H3>
<PRE>
public static final int <B>MEM_NA</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_ADD_R"><!-- --></A><H3>
MEM_ADD_R</H3>
<PRE>
public static final int <B>MEM_ADD_R</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_ADD_W"><!-- --></A><H3>
MEM_ADD_W</H3>
<PRE>
public static final int <B>MEM_ADD_W</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_RMV_R"><!-- --></A><H3>
MEM_RMV_R</H3>
<PRE>
public static final int <B>MEM_RMV_R</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_RMV_W"><!-- --></A><H3>
MEM_RMV_W</H3>
<PRE>
public static final int <B>MEM_RMV_W</B></PRE>
<DL>
</DL>
<HR>

<A NAME="MEM_NC"><!-- --></A><H3>
MEM_NC</H3>
<PRE>
public static final int <B>MEM_NC</B></PRE>
<DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="Xipc()"><!-- --></A><H3>
Xipc</H3>
<PRE>
public <B>Xipc</B>()</PRE>
<DL>
<DD>The constructor for new Xipc objects.
 An Xipc object is required to log in to a network instance.  The object is
 locked during most operations (during invocation of synchronized methods).	Any
 thread attempting to execute a synchronized method of the object while another
 thread is doing so will become blocked until the latter thread finishes the
 operation.  This is particularly significant when blocking operations are
 performed.  If, for instance, one thread is to send to a queue while another
 thread is blocked waiting to receive from a queue, then the sending thread must
 either wait until the blocked thread becomes unblocked, or it must use a
 different Xipc object to do the send.
 <p><dt><b>Example:</b>
 <dd><pre>
 Xipc connect1 = new Xipc();
 Xipc connect2 = new Xipc();
 int uid1 = connect1.XipcLogin("@server:NetInstance", "user1");  // login via
 connect1 object
 int uid2 = connect2.XipcLogin("@server:NetInstance", "user2");  // login via
 connect2 object
 </pre>
 Two Xipc objects are declared and created, and each does an XipcLogin,
 returning the user id of the login.</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="SEM_TIMEOUT(int)"><!-- --></A><H3>
SEM_TIMEOUT</H3>
<PRE>
public static final int <B>SEM_TIMEOUT</B>(int&nbsp;t)</PRE>
<DL>
<DD>Parameter value to SemAcquire and SemWait.
 If the request specified in the method call cannot be satisfied, the thread
 that called the method is blocked until the request is completed, or until
 <I>t</I> seconds have elapsed after which the method returns with return code
 XipcErr.SEM_ER_TIMEOUT.
 See general information on <A HREF="XipcBlockingOption.html">blocking option
 parameters</A>.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - Maximum time to wait.<DT><B>Returns:</B><DD>A value to use as a SemAcquire or SemWait <I>BlockOpt</I>
                   parameter.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid = connection.SemCreate("event", Xipc.SEM_CLEAR);
                   SidList sl = Xipc.SemListBuild(sid);
                   int retcode = connection.SemWait(Xipc.SEM_ANY, sl, retsid,
                   Xipc.SEM_TIMEOUT(60));
                   if (retcode == Xipc.SEM_ER_TIMEOUT)
                   System.out.println("event semaphore was not set within 1
                   minute");
                   </pre>
                   After logging in to an instance through an Xipc object, an
                   event semaphore is created in a cleared state, and its sid is
                   put into a SidList.
                   SemWait is used with a <I>BlockOpt</I> of Xipc.SEM_WAIT(60)
                   to wait a maximum of 60 seconds for the semaphore to be set
                   by some other user.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><CODE>SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_TIMEOUT(int)"><!-- --></A><H3>
QUE_TIMEOUT</H3>
<PRE>
public static final int <B>QUE_TIMEOUT</B>(int&nbsp;t)</PRE>
<DL>
<DD>Parameter value to QueReceive and QueSend.
 If the request specified in the method call cannot be satisfied, the thread
 that called the method is blocked until the request is completed, or until
 <I>t</I> seconds have elapsed after which the method returns with return code
 XipcErr.QUE_ER_TIMEOUT.
 See general information on <A HREF="XipcBlockingOption.html">blocking option
 parameters</A>.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - Maximum time to wait.<DT><B>Returns:</B><DD>A value to use as a QueReceive or QueSend <I>BlockOpt</I>
                   parameter.
                   <p><dt><b>Example:</b>
                   <dd>See QueReceive <A HREF="#QueReceive Example">example</A>.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><CODE>QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_TIMEOUT(int)"><!-- --></A><H3>
MEM_TIMEOUT</H3>
<PRE>
public static final int <B>MEM_TIMEOUT</B>(int&nbsp;t)</PRE>
<DL>
<DD>Parameter value to MemLock and MemRead.
 If the request specified in the method call cannot be satisfied, the thread
 that called the method is blocked until the request is completed, or until
 <I>t</I> seconds have elapsed after which the method returns with return code
 XipcErr.MEM_ER_TIMEOUT.
 See general information on <A HREF="XipcBlockingOption.html">blocking option
 parameters</A>.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>t</CODE> - Maximum time to wait.<DT><B>Returns:</B><DD>A value to use as a MemLock or MemRead <I>BlockOpt</I>
                   parameter.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid = connection.MemAccess("segment1");
                   MidList ml =
                   Xipc.MemListBuild(Xipc.MemSectionBuild(mid,0,10));
                   int retcode = connection.MemLock(Xipc.MEM_ANY, ml, null,
                   Xipc.MEM_TIMEOUT(30));
                   if (retcode>=0)
                   System.out.println("Locked first 10 bytes of segment1");
                   else if (retcode==Xipc.MEM_ER_TIMEOUT)
                   System.out.println("Waited 30 seconds; could not lock
                   section");
                   else System.out.println("Error: " + Xipc.XipcError(retcode));
                   </pre>
                   After logging in, a MidList is created containing a section
                   overlaying the first 10 bytes of "segment1".
                   MemLock is used to lock the section, blocking for at most 30
                   seconds while waiting to do so.	A message is printed
                   indicating the outcome of the MemLock operation.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)"><CODE>MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemRead(int, int, int, byte[], int)"><CODE>MemRead(int, int, int, byte[], int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_TRUNCATE(int)"><!-- --></A><H3>
QUE_TRUNCATE</H3>
<PRE>
public static final int <B>QUE_TRUNCATE</B>(int&nbsp;MsgLen)</PRE>
<DL>
<DD>Parameter value to QueReceive.
 Used to modify the message length parameter of a QueReceive.	Causes messages
 that are larger than specified length to be truncated.	Without using
 QUE_TRUNCATE, QueReceive returns XipcErr.QUE_ER_TOOBIG if the message is larger
 than the specified length.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>MsgLen</CODE> - Length to truncate received message to.
                   <p><dt><b>Example:</b> <dd>See QueReceive <A
                   HREF="#QueReceive Example">example</A>. <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_BYTES_HIGH(int, int)"><!-- --></A><H3>
QUE_T_BYTES_HIGH</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_BYTES_HIGH</B>(int&nbsp;Qid,
                                                    int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when number of bytes written to queue <I>Qid</I>
 becomes higher than <I>N</I> percent of the queues byte capacity.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_BYTES_LOW(int, int)"><!-- --></A><H3>
QUE_T_BYTES_LOW</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_BYTES_LOW</B>(int&nbsp;Qid,
                                                   int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when number of bytes written to queue <I>Qid</I>
 becomes lower than <I>N</I> percent of the queues byte capacity.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_MSGS_HIGH(int, int)"><!-- --></A><H3>
QUE_T_MSGS_HIGH</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_MSGS_HIGH</B>(int&nbsp;Qid,
                                                   int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when number of messages written to queue <I>Qid</I>
 becomes higher than <I>N</I> percent of queues message capacity.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_MSGS_LOW(int, int)"><!-- --></A><H3>
QUE_T_MSGS_LOW</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_MSGS_LOW</B>(int&nbsp;Qid,
                                                  int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when number of messages written to queue <I>Qid</I>
 becomes lower than <I>N</I> percent of queues message capacity.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_PUT(int)"><!-- --></A><H3>
QUE_T_PUT</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_PUT</B>(int&nbsp;Qid)</PRE>
<DL>
<DD>Trigger event when a message is put onto queue <I>Qid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_GET(int)"><!-- --></A><H3>
QUE_T_GET</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_GET</B>(int&nbsp;Qid)</PRE>
<DL>
<DD>Trigger event when a message is removed from queue <I>Qid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_PUT_PREQ(int, int)"><!-- --></A><H3>
QUE_T_PUT_PREQ</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_PUT_PREQ</B>(int&nbsp;Qid,
                                                  int&nbsp;Prio)</PRE>
<DL>
<DD>Trigger event when a message of priority <I>P</I> is put onto queue <I>Qid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_GET_PREQ(int, int)"><!-- --></A><H3>
QUE_T_GET_PREQ</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_GET_PREQ</B>(int&nbsp;Qid,
                                                  int&nbsp;Prio)</PRE>
<DL>
<DD>Trigger event when a message of priority <I>P</I> is removed from queue
 <I>Qid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_PUT_PRGT(int, int)"><!-- --></A><H3>
QUE_T_PUT_PRGT</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_PUT_PRGT</B>(int&nbsp;Qid,
                                                  int&nbsp;Prio)</PRE>
<DL>
<DD>Trigger event when a message of priority greater than <I>P</I>
 is put onto queue <I>Qid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_GET_PRGT(int, int)"><!-- --></A><H3>
QUE_T_GET_PRGT</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_GET_PRGT</B>(int&nbsp;Qid,
                                                  int&nbsp;Prio)</PRE>
<DL>
<DD>Trigger event when a message of priority greater than <I>P</I>
 is removed from queue <I>Qid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_PUT_PRLT(int, int)"><!-- --></A><H3>
QUE_T_PUT_PRLT</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_PUT_PRLT</B>(int&nbsp;Qid,
                                                  int&nbsp;Prio)</PRE>
<DL>
<DD>Trigger event when a message of priority less than <I>P</I>
 is put onto queue <I>Qid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_GET_PRLT(int, int)"><!-- --></A><H3>
QUE_T_GET_PRLT</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_GET_PRLT</B>(int&nbsp;Qid,
                                                  int&nbsp;Prio)</PRE>
<DL>
<DD>Trigger event when a message of priority less than <I>P</I>
 is removed from queue <I>Qid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_USER_PUT(int, int)"><!-- --></A><H3>
QUE_T_USER_PUT</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_USER_PUT</B>(int&nbsp;Qid,
                                                  int&nbsp;Uid)</PRE>
<DL>
<DD>Trigger event when a message is put onto queue <I>Qid</I>
 by user <I>Uid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_USER_GET(int, int)"><!-- --></A><H3>
QUE_T_USER_GET</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_USER_GET</B>(int&nbsp;Qid,
                                                  int&nbsp;Uid)</PRE>
<DL>
<DD>Trigger event when a message is removed from queue <I>Qid</I>
 by user <I>Uid</I>.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_POOL_HIGH(int)"><!-- --></A><H3>
QUE_T_POOL_HIGH</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_POOL_HIGH</B>(int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when the allocated size of the message text pool becomes higher
 than <I>N</I> percent of the instances capacity.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_POOL_LOW(int)"><!-- --></A><H3>
QUE_T_POOL_LOW</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_POOL_LOW</B>(int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when the allocated size of the message text pool becomes lower
 than <I>N</I> percent of the instances capacity.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_HEADER_HIGH(int)"><!-- --></A><H3>
QUE_T_HEADER_HIGH</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_HEADER_HIGH</B>(int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when the number of allocated message headers becomes higher than
 <I>N</I> percent of the instances capacity.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_T_HEADER_LOW(int)"><!-- --></A><H3>
QUE_T_HEADER_LOW</H3>
<PRE>
public static final <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A> <B>QUE_T_HEADER_LOW</B>(int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when the number of allocated message headers becomes lower than
 <I>N</I> percent of the instances capacity.
 Calls to QueSys trigger spec methods are used as arguments to
 <tt>Xipc.QueTrigger()</tt> and <tt>Xipc.QueUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueTrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueTrigger(int, javaxipc30.QueTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#QueUntrigger(int, javaxipc30.QueTriggerSpec)"><CODE>QueUntrigger(int, javaxipc30.QueTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_READ(int, int, int)"><!-- --></A><H3>
MEM_T_READ</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_READ</B>(int&nbsp;Mid,
                                              int&nbsp;Offset,
                                              int&nbsp;Size)</PRE>
<DL>
<DD>Trigger event when data is read from the shared memory area specified by
 <I>Mid</I>, <I>Offset</I> and <I>Size</I>
 (or any part of it).
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_WRITE(int, int, int)"><!-- --></A><H3>
MEM_T_WRITE</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_WRITE</B>(int&nbsp;Mid,
                                               int&nbsp;Offset,
                                               int&nbsp;Size)</PRE>
<DL>
<DD>Trigger event when data is written into the shared memory area specified by
 <I>Mid</I>, <I>Offset</I> and <I>Size</I>
 (or any part of it).
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_LOCK(int, int, int)"><!-- --></A><H3>
MEM_T_LOCK</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_LOCK</B>(int&nbsp;Mid,
                                              int&nbsp;Offset,
                                              int&nbsp;Size)</PRE>
<DL>
<DD>Trigger event when the shared memory area specified by <I>Mid</I>,
 <I>Offset</I> and <I>Size</I>
 (or any part of it) is locked.
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_UNLOCK(int, int, int)"><!-- --></A><H3>
MEM_T_UNLOCK</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_UNLOCK</B>(int&nbsp;Mid,
                                                int&nbsp;Offset,
                                                int&nbsp;Size)</PRE>
<DL>
<DD>Trigger event when the shared memory area specified by <I>Mid</I>,
 <I>Offset</I> and <I>Size</I>
 (or any part of it) is unlocked.
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_USER_READ(int, int, int, int)"><!-- --></A><H3>
MEM_T_USER_READ</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_USER_READ</B>(int&nbsp;Mid,
                                                   int&nbsp;Offset,
                                                   int&nbsp;Size,
                                                   int&nbsp;Uid)</PRE>
<DL>
<DD>Trigger event when user <I>Uid</I> reads data from the shared memory area
 specified by <I>Mid</I>, <I>Offset</I> and <I>Size</I> (or any part of it).
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_USER_WRITE(int, int, int, int)"><!-- --></A><H3>
MEM_T_USER_WRITE</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_USER_WRITE</B>(int&nbsp;Mid,
                                                    int&nbsp;Offset,
                                                    int&nbsp;Size,
                                                    int&nbsp;Uid)</PRE>
<DL>
<DD>Trigger event when user <I>Uid</I> writes data to the shared memory area
 specified by <I>Mid</I>, <I>Offset</I> and <I>Size</I> (or any part of it).
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_USER_LOCK(int, int, int, int)"><!-- --></A><H3>
MEM_T_USER_LOCK</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_USER_LOCK</B>(int&nbsp;Mid,
                                                   int&nbsp;Offset,
                                                   int&nbsp;Size,
                                                   int&nbsp;Uid)</PRE>
<DL>
<DD>Trigger event when user <I>Uid</I> locks the shared memory area specified by
 <I>Mid</I>, <I>Offset</I> and <I>Size</I> (or any part of it).
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_USER_UNLOCK(int, int, int, int)"><!-- --></A><H3>
MEM_T_USER_UNLOCK</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_USER_UNLOCK</B>(int&nbsp;Mid,
                                                     int&nbsp;Offset,
                                                     int&nbsp;Size,
                                                     int&nbsp;Uid)</PRE>
<DL>
<DD>Trigger event when user <I>Uid</I> unlocks the shared memory area specified by
 <I>Mid</I>, <I>Offset</I> and <I>Size</I> (or any part of it).
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_POOL_HIGH(int)"><!-- --></A><H3>
MEM_T_POOL_HIGH</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_POOL_HIGH</B>(int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when the allocated size of the shared memory pool becomes higher
 than <I>N</I> percent of its capacity.
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_POOL_LOW(int)"><!-- --></A><H3>
MEM_T_POOL_LOW</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_POOL_LOW</B>(int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when the allocated size of the shared memory pool becomes lower
 than <I>N</I> percent of its capacity.
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_SECTION_HIGH(int)"><!-- --></A><H3>
MEM_T_SECTION_HIGH</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_SECTION_HIGH</B>(int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when the number of allocated sections becomes higher than
 <I>N</I> percent of the capacity.
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MEM_T_SECTION_LOW(int)"><!-- --></A><H3>
MEM_T_SECTION_LOW</H3>
<PRE>
public static final <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A> <B>MEM_T_SECTION_LOW</B>(int&nbsp;N)</PRE>
<DL>
<DD>Trigger event when the number of allocated sections becomes lower than <I>N</I>
 percent of the capacity.
 Calls to MemSys trigger spec methods are used as arguments to
 <tt>Xipc.MemTrigger()</tt> and <tt>Xipc.MemUntrigger()</tt>.<DD><DL>
<DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#MemTrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemTrigger(int, javaxipc30.MemTriggerSpec)</CODE></A>, 
<A HREF="../javaxipc30/Xipc.html#MemUntrigger(int, javaxipc30.MemTriggerSpec)"><CODE>MemUntrigger(int, javaxipc30.MemTriggerSpec)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="ClearBuf()"><!-- --></A><H3>
ClearBuf</H3>
<PRE>
void <B>ClearBuf</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="putArr(byte[], int, byte[], int, int)"><!-- --></A><H3>
putArr</H3>
<PRE>
static void <B>putArr</B>(byte[]&nbsp;src,
                   int&nbsp;srcOffset,
                   byte[]&nbsp;dest,
                   int&nbsp;destOffset,
                   int&nbsp;length)</PRE>
<DL>
</DL>
<HR>

<A NAME="putArr(byte[], byte[], int, int)"><!-- --></A><H3>
putArr</H3>
<PRE>
static void <B>putArr</B>(byte[]&nbsp;src,
                   byte[]&nbsp;dest,
                   int&nbsp;destOffset,
                   int&nbsp;length)</PRE>
<DL>
</DL>
<HR>

<A NAME="putString(java.lang.String, int, byte[], int)"><!-- --></A><H3>
putString</H3>
<PRE>
static void <B>putString</B>(java.lang.String&nbsp;str,
                      int&nbsp;len,
                      byte[]&nbsp;destBuffer,
                      int&nbsp;destOffset)</PRE>
<DL>
</DL>
<HR>

<A NAME="putInt(int, byte[], int)"><!-- --></A><H3>
putInt</H3>
<PRE>
static void <B>putInt</B>(int&nbsp;I,
                   byte[]&nbsp;buf,
                   int&nbsp;offset)</PRE>
<DL>
</DL>
<HR>

<A NAME="getInt(byte[], int)"><!-- --></A><H3>
getInt</H3>
<PRE>
static int <B>getInt</B>(byte[]&nbsp;b,
                  int&nbsp;off)</PRE>
<DL>
</DL>
<HR>

<A NAME="putList(javaxipc30.MidList, byte[], int)"><!-- --></A><H3>
putList</H3>
<PRE>
static void <B>putList</B>(<A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;src,
                    byte[]&nbsp;dest,
                    int&nbsp;offset)</PRE>
<DL>
</DL>
<HR>

<A NAME="putList(javaxipc30.QidList, byte[], int)"><!-- --></A><H3>
putList</H3>
<PRE>
static void <B>putList</B>(<A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;src,
                    byte[]&nbsp;dest,
                    int&nbsp;offset)</PRE>
<DL>
</DL>
<HR>

<A NAME="putList(javaxipc30.SidList, byte[], int)"><!-- --></A><H3>
putList</H3>
<PRE>
static void <B>putList</B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;src,
                    byte[]&nbsp;dest,
                    int&nbsp;offset)</PRE>
<DL>
</DL>
<HR>

<A NAME="XipcAbort(int)"><!-- --></A><H3>
XipcAbort</H3>
<PRE>
public final int <B>XipcAbort</B>(int&nbsp;Uid)</PRE>
<DL>
<DD>Abort a user by forcing a logout.
 <P>XipcAbort() logs the specified user out of an <I>XIPC</I> instance.
 Resources held by the user are released, as follows:
 <UL>
 <LI>All semaphores held by the user are released. </LI>
 <LI>If user <I>Uid</I> is currently blocked on a SemAcquire() or SemWait()
 operation, that operation is cancelled before the user is logged out and
 XipcErr.SEM_ER_NOTLOGGEDIN error code is returned. </LI>
 <LI>If the aborted user is currently blocked on a QuePut(), QueGet(),
 QueWrite(), QueSend() or QueReceive() operation, then that operation is
 cancelled before the user is logged out and XipcErr.QUE_ER_NOTLOGGEDIN error
 code is returned. </LI>
 <LI>All memory sections owned by the user are released. </LI>
 <LI>If user <I>Uid</I> is currently blocked on a blocking MemSys operation
 (i.e. MemWrite(), MemRead(), MemLock() or MemSecOwn()), that operation is
 cancelled before the user is logged out and XipcErr.MEM_ER_NOTLOGGEDIN error
 code is returned. </LI>
 </UL>
 <P>A user cannot call XipcAbort() specifying his own <I>Uid</I>.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Uid</CODE> - The User ID of the user to be aborted.<DT><B>Returns:</B><DD><dd>RC>=0 - Abort Successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.XIPC_ER_BADUID - Invalid <I>Uid</I> parameter.
                   <dd>XipcErr.XIPC_ER_NOTLOGGEDIN - User not logged into
                   <I>XIPC</I> (User never logged in, is disconnected or was
                   aborted).
                   <dd>XipcErr.XIPC_ER_SYSERR - An internal error has occurred
                   while processing the request.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connect1 = new Xipc();
                   Xipc connect2 = new Xipc();
                   int uid1 = connect1.XipcLogin("@server:NetInstance",
                   "user1");
                   int uid2 = connect2.XipcLogin("@server:NetInstance",
                   "user2");
                   connect2.XipcAbort(uid1);
                   </pre>
                   Two Xipc objects are declared and created, and each does an
                   XipcLogin, returning the user id of the login.  Then one Xipc
                   object is used to abort the other objects login.</DL>
</DD>
</DL>
<HR>

<A NAME="XipcError(int)"><!-- --></A><H3>
XipcError</H3>
<PRE>
public static final java.lang.String <B>XipcError</B>(int&nbsp;ErrCode)</PRE>
<DL>
<DD>Xipc error code translation function.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>ErrCode</CODE> - The Xipc error code whose translation is desired.<DT><B>Returns:</B><DD>A String containing a brief translation of the error code it
                   is passed.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   if (uid<0)
                   {
                   String errorMsg = Xipc.XipcError(uid);
                   System.out.println("Login Failed: " + errorMsg);
                   }
                   </pre>
                   Here an XipcLogin is attempted, and if the return code is
                   negative (indicating failure) then XipcError() is used to
                   translate the return code to an error message string.  Note
                   that since XipcError() is a <tt>static</tt> method, it is
                   called using the class name <tt>Xipc</tt> rather than the
                   object name.</DL>
</DD>
</DL>
<HR>

<A NAME="XipcFreeze()"><!-- --></A><H3>
XipcFreeze</H3>
<PRE>
public final int <B>XipcFreeze</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="XipcUnfreeze()"><!-- --></A><H3>
XipcUnfreeze</H3>
<PRE>
public final int <B>XipcUnfreeze</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="XipcLogin(java.lang.String, java.lang.String)"><!-- --></A><H3>
XipcLogin</H3>
<PRE>
public final int <B>XipcLogin</B>(java.lang.String&nbsp;instanceName,
                           java.lang.String&nbsp;userName)</PRE>
<DL>
<DD>Log in to a network instance.
 XipcLogin() logs the object, with user name as <I>userName</I>, into the
 instance identified by <I>instanceName</I>. It also sets that login as the
 object's <I>current login</I>.
 <P><I>instanceName</I> specifies the target network instance in the following
 format: @<I>NodeName</I>:<I>NetworkName</I> where:
 <UL>
 <LI>@ character always precedes the network instance specification. </LI>
 <LI><I>NodeName</I> is the name of the node where the instance resides.
 The <I>NodeName</I> part must be followed by a colon. </LI>
 <LI><I>NetworkName</I> is the instance network name </LI>
 </UL>
 <P>The requested instance must have been started previously. The object must
 not be currently logged in to an instance. XipcLogin() must succeed before any
 other <I>XIPC</I> methods can be invoked.
 <P>If the <I>userName</I> is specified as XIPC_LOGIN_SUPERUSER, the user is
 logged in as Super User. A Super User login can be used to access a
 &quot;corrupt&quot; instance or an instance that has exhausted some of its
 resources, preventing regular users from logging in.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>instanceName</CODE> - A String of the form @NodeName:NetworkName.<DD><CODE>userName</CODE> - A String containing a user login name. Need
                   not be unique. May be XIPC_LOGIN_SUPERUSER.<DT><B>Returns:</B><DD><dd>RC>=0 - Login successful. RC is the Uid of the user.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.XIPC_ER_BADCONFIGNAME - The <I>instanceName</I>
                   specification is invalid or missing.
                   <dd>XipcErr.XIPC_ER_BADUSERNAME - Invalid <I>userName</I>
                   parameter.
                   <dd>XipcErr.XIPC_ER_CAPACITY - Internal capacity exceeded.
                   <dd>XipcErr.XIPC_ER_BUSY - User already connected to an
                   <I>XIPC</I> instance.
                   <dd>XipcErr.XIPC_ER_NOACCESS - Unable to connect to
                   <I>XIPC</I>.
                   <dd>XipcErr.XIPC_ER_SYSERR - An internal error has occurred
                   while processing the request.
                   <dd>XipcErr.XIPCNET_ER_BADNETNAME - Network name missing
                   &quot;@&quot; prefix or &quot;:&quot; seperator.
                   <dd>XipcErr.XIPCNET_ER_NOFORK - Process limit exceeded on
                   server.
                   <dd>XipcErr.XIPCNET_ER_SESSION - Cannot connect to
                   <I>instanceName</I> instance.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   </pre>
                   Here an XipcLogin is attempted using a newly created Xipc
                   object.
                   The return value is the user id of the login.</DL>
</DD>
</DL>
<HR>

<A NAME="XipcLogout()"><!-- --></A><H3>
XipcLogout</H3>
<PRE>
public final int <B>XipcLogout</B>()</PRE>
<DL>
<DD>Log out of a network instance.
 <P>XipcLogout() logs the calling user out of the instance it is currently
 logged into. Resources held by the user are released as follows:
 <UL>
 <LI>All <I>XIPC</I> semaphores held by the user are released. </LI>
 <LI>All <I>XIPC</I> memory sections held by the user are released. </LI>
 </UL>
 <P>Following the XipcLogout() call, the object's <I>current login</I> is
 undefined. All <I>XIPC</I> methods requiring a valid <I>current login</I>
 will fail until the an XipcLogin() call from that object.
 <p><DD><DL>
<DT><B>Returns:</B><DD><dd>RC>=0 - Logout Successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.XIPC_ER_NOTLOGGEDIN - User not logged into
                   <I>XIPC</I> (User never logged in, is disconnected or was
                   aborted).
                   <dd>XipcErr.XIPC_ER_SYSERR - An internal error has occurred
                   while processing the request.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <dd>XipcErr.XIPCNET_ER_SYSERR - Operating system error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server1:NetInstance",
                   "user");
                   int retcode = connection.XipcLogout();
                   uid = connection.XipcLogin("@server2:NetInstance", "user");
                   </pre>
                   A newly created Xipc object is used to first login to an
                   instance on machine 'server1', then logout, and then login to
                   an instance on machine 'server2'.</DL>
</DD>
</DL>
<HR>

<A NAME="XipcGetOpt(int)"><!-- --></A><H3>
XipcGetOpt</H3>
<PRE>
public final int <B>XipcGetOpt</B>(int&nbsp;Option)</PRE>
<DL>
<DD>For obtaining the values of various parameters.
 <P>Currently, the only supported value for <I>Option</I> is
 XIPC_GETOPT_MAXTEXTSIZE, which causes the value of the objects MAX_TEXT_SIZE to
 be returned.  MAX_TEXT_SIZE is the maximum number of bytes of text that can be
 transfered by an Xipc text transfer operation (QueReceive, QueSend, MemRead or
 MemWrite).
 <P>If called while logged in, the actual value of MAX_TEXT_SIZE is returned
 (which was either set by a call to XipcSetOpt, or was set during login to the
 value in the network instance's config file).
 <P>If called while not logged in, the value set by XipcSetOpt is returned, or
 XipcErr.XIPC_ER_OPTIONNOTSET is returned if the option was not set by a call to
 XipcSetOpt.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Option</CODE> - An Xipc constant specifying which option
                   parameter value to obtain.<DT><B>Returns:</B><DD><dd>RC>=0 - The value of the requested option parameter.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.XIPC_ER_OPTIONNOTSET - Option specified has not
                   been set.
                   <dd>XipcErr.XIPC_ER_INVALIDSETOPTION - Invalid Option
                   specified to function.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int maxTextSize =
                   connection.XipcGetOpt(Xipc.XIPC_GETOPT_MAXTEXTSIZE);
                   byte[] buffer = new byte[maxTextSize];
                   </pre>
                   A newly created Xipc object is used to first login, and then
                   XipcGetOpt is used to obtain the value of MAX_TEXT_SIZE
                   (which here depends on the instances configuration file).
                   A buffer (array of byte) is then created large enough to hold
                   the largest message that can be sent or received.</DL>
</DD>
</DL>
<HR>

<A NAME="XipcSetOpt(int, int)"><!-- --></A><H3>
XipcSetOpt</H3>
<PRE>
public final int <B>XipcSetOpt</B>(int&nbsp;Option,
                            int&nbsp;Value)</PRE>
<DL>
<DD>For changing the values of various parameters.
 <P>Currently, the only supported value for <I>Option</I> is
 XIPC_SETOPT_MAXTEXTSIZE, which causes <I>Value</I> to be used as the value of
 the objects MAX_TEXT_SIZE at login.  MAX_TEXT_SIZE is the maximum number of
 bytes of text that can be transfered by an Xipc text transfer operation
 (QueReceive, QueSend, MemRead or MemWrite).
 If not set with XipcSetOpt(), the value used is the value specified in the
 network section of the instances config file.
 <P>If <I>Value</I> is 0, then this resets the option to it's default, which is
 to use the value specified in the network section of the instanes config file.
 <P>This option may not be set while logged in.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Option</CODE> - An Xipc constant specifying which option
                   parameter value to set.<DD><CODE>Value</CODE> - The value to set the option parameter to.<DT><B>Returns:</B><DD><dd>RC>=0 - The operation succeeded.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.XIPC_ER_BUSY - Object is already connected to an
                   instance.
                   <dd>XipcErr.XIPC_ER_INVALIDSETOPTION - Invalid Option or
                   Value specified to function.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   byte[] buffer = new byte[2048];
                   retcode = connection.XipcSetOpt(Xipc.XIPC_SETOPT_MAXTEXTSIZE,
                   2048);
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   </pre>
                   An Xipc object is created, and a buffer of size 2048 bytes is
                   allocated.
                   Then XipcSetOpt is used to set the MAX_TEXT_SIZE to 2048,
                   overriding the value specified in the instances configuration
                   file.  Then a login is performed.</DL>
</DD>
</DL>
<HR>

<A NAME="SemAccess(java.lang.String)"><!-- --></A><H3>
SemAccess</H3>
<PRE>
public final int <B>SemAccess</B>(java.lang.String&nbsp;Name)</PRE>
<DL>
<DD>Access an existing semaphore.
 SemAccess() accesses an existing semaphore in SemSys. <I>Name</I> is used for
 identifying the desired semaphore. The method returns the <I>Sid</I>
 of the accessed semaphore.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Name</CODE> - A String that contains the symbolic name
                   identifying the desired semaphore. <I>Name</I> must not
                   exceed SEM_LEN_XIPCNAME characters, must identify an existing
                   semaphore and cannot be SEM_PRIVATE.<DT><B>Returns:</B><DD><dd>RC>=0 - Access successful. RC is semaphore ID (Sid). Sid
                   is to be used in all subsequent SemSys calls that refer to
                   this semaphore.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADSEMNAME - Invalid <I>Name</I>
                   parameter.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTFOUND - Semaphore with <I>Name</I> does
                   not exist.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemCreate("event1", Xipc.SEM_CLEAR);
                   if (sid1 == XipcErr.SEM_ER_DUPLICATE) sid1 =
                   connection.SemAccess("event1");
                   </pre>
                   After logging in to an instance through an Xipc object, an
                   attempt is made to create an event semaphore with the name
                   "event1".
                   If the return code indicates that a semaphore with that name
                   already exists, then SemAccess is used to get it's semaphore
                   id.</DL>
</DD>
</DL>
<HR>

<A NAME="SemAcquire(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><!-- --></A><H3>
SemAcquire</H3>
<PRE>
public final int <B>SemAcquire</B>(int&nbsp;AcquireType,
                            <A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
                            <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid,
                            int&nbsp;BlockOpt)</PRE>
<DL>
<DD>Acquire resource semaphores.
 SemAcquire() attempts to obtain the semaphores in <I>SidList</I> for the
 calling user based on the values of <I>AcquireType</I> and <I>BlockOpt</I>.
 <P>The value of <I>AcquireType</I> specifies how to satisfy the requested
 acquire:
 <UL>
 <LI>If <I>AcquireType</I> = SEM_ANY, the request is considered satisfied when
 any one of the semaphores in <I>SidList</I> has been acquired. </LI>
 <LI>If <I>AcquireType</I> = SEM_ALL, the request is not considered satisfied
 until all the semaphores in <I>SidList</I> have been acquired. Semaphores are
 accumulated as they become available until the entire <I>SidList</I>
 has been acquired. </LI>
 <LI>If <I>AcquireType</I> = SEM_ATOMIC, the request is not considered satisfied
 until all the semaphores in <I>SidList</I> are available and then acquired in a
 single atomic operation. Individual semaphores in <I>SidList</I>
 are not accumulated as they become available. In this way it differs from<I>
 AcquireType</I> = SEM_ALL. </LI>
 </UL>
 <P>The value of <I>BlockOpt</I> specifies whether and how to block for the
 satisfaction of the requested acquire in case it cannot be satisfied
 immediately. See <A HREF="XipcBlockingOption.html">blocking option
 parameter</A> for further information.
 <P>For satisfied SemAcquire() calls, the Sid of the last acquired semaphore is
 placed in <I>RetSid</I>.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>AcquireType</CODE> - One of SEM_ANY, SEM_ALL or SEM_ATOMIC,
                   depending on the acquisition criteria desired.<DD><CODE>SidList</CODE> - A list of Sids being requested. This list
                   should be a SidList built by SemListBuild() and updated by
                   SemListAdd().<DD><CODE>RetSid</CODE> - An XintRef object that gets assigned by
                   SemAcquire upon its return. Successful acquire operations
                   (RC>=0) return with RetSid containing the last acquired Sid.
                   Interrupted acquire operations (return code equals
                   XipcErr.SEM_ER_DESTROYED or XipcErr.SEM_ER_CANCEL) return
                   with RetSid containing the destroyed or cancelled Sid. Failed
                   calls with return code equal to XipcErr.SEM_ER_BADSID return
                   with RetSid containing the invalid Sid. The contents of
                   RetSid is otherwise undefined. <tt>null</tt> may be passed if
                   the value returned by this parameter is not required.<DD><CODE>BlockOpt</CODE> - One of SEM_WAIT, SEM_NOWAIT or SEM_TIMEOUT(t)
                   for an integer t. See <A
                   HREF="XipcBlockingOption.html">blocking option parameter</A>
                   for further information.<DT><B>Returns:</B><DD><dd>RC>=0 - Acquire successful. If <I>AcquireType</I> =
                   SEM_ANY then one of the requested semaphores has been
                   acquired and RetSid contains the Sid of the acquired
                   semaphore. If <I>AcquireType</I> = SEM_ALL or SEM_ATOMIC then
                   all requested semaphores have been acquired by the calling
                   user and RetSid contains the Sid of the last semaphore
                   acquired.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADACQUIRETYPE - Invalid
                   <I>AcquireType</I> parameter.
                   <dd>XipcErr.SEM_ER_BADBLOCKOPT - Invalid <I>BlockOpt</I>.
                   <dd>XipcErr.SEM_ER_BADOPTION - Invalid <I>BlockOpt</I>
                   parameter.
                   <dd>XipcErr.SEM_ER_BADSID - <I>SidList</I> contains a bad
                   Sid. <I>RetSid</I> contains the invalid Sid.
                   <dd>XipcErr.SEM_ER_BADSIDLIST - Bad <I>SidList</I>.
                   <dd>XipcErr.SEM_ER_CANCEL - Another user issued a SemCancel()
                   call for one of the semaphores in <I>SidList</I>. The blocked
                   SemAcquire() operation was cancelled, and no semaphores were
                   acquired. <I>RetSid</I> contains the Sid of the destroyed
                   semaphore.
                   <dd>XipcErr.SEM_ER_CAPACITY - Internal capacity exceeded.
                   <dd>XipcErr.SEM_ER_DESTROYED - Another user destroyed a
                   semaphore that was being waited on by this user. The blocked
                   acquire operation was cancelled. No semaphores were acquired.
                   <I>RetSid</I> contains the Sid of the destroyed semaphore.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.SEM_ER_NOWAIT - <I>BlockOpt</I> of SEM_NOWAIT was
                   specified and the request was not immediately satisfied.
                   <dd>XipcErr.SEM_ER_TIMEOUT - The time out period for the
                   blocked acquire operation has expired without satisfying the
                   request.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemAccess("resource1");
                   int sid2 = connection.SemAccess("resource2");
                   SidList sl = Xipc.SemListBuild(sid1);
                   Xipc.SemListAdd(sl, sid2);
                   XintRef retsid = new XintRef(-1);
                   int retcode = connection.SemAcquire(Xipc.SEM_ANY, sl, retsid,
                   Xipc.SEM_TIMEOUT(60));
                   if (retcode>=0)
                   {
                   int acquiredSid = retsid.getValue();
                   if (acquiredSid == sid1)
                   System.out.println("resource1 was acquired");
                   else
                   System.out.println("resource2 was acquired");
                   }
                   else if (retcode == XipcErr.SEM_ER_TIMEOUT)
                   System.out.println("one minute passed; neither resource
                   acquired");
                   else System.out.println("Error: " + Xipc.XipcError(retcode));
                   </pre>
                   After logging in to an instance through an Xipc object, two
                   existing resource semaphores are accessed, and their sid's
                   are put into a SidList. An XintRef object is created to get
                   the sid of the acquired semaphore.  SemAcquire is performed
                   to acquire either resource within one minute.
                   A message is printed indicating which resource was acquired,
                   or that a timeout or error occurred.</DL>
</DD>
</DL>
<HR>

<A NAME="SemCancel(javaxipc30.SidList, javaxipc30.XintRef)"><!-- --></A><H3>
SemCancel</H3>
<PRE>
public final int <B>SemCancel</B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
                           <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid)</PRE>
<DL>
<DD>Cancel blocked semaphore operations.
 SemCancel() cancels blocked SemWait() or SemAcquire() operations involving the
 semaphores in <I>SidList</I>. Users blocked on any of the listed semaphores are
 notified of the cancellation of their SemWait() or SemAcquire() requests by
 receiving a return code equal to XipcErr.SEM_ER_CANCEL.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>SidList</CODE> - A list of Sids for which cancellation of
                   blocked operations is to be performed. This list should be
                   built by SemListBuild() and updated by SemListAdd().<DD><CODE>RetSid</CODE> - An XintRef object that gets assigned by
                   SemCancel() on return. For failed calls, where return code
                   equals XipcErr.SEM_ER_BADSID, <I>RetSid</I> contains the
                   invalid Sid. For successful calls <I>RetSid</I> contains the
                   Sid of the last semaphore having its blocked operations
                   cancelled. In all other cases, the contents of <I>RetSid</I>
                   is undefined. <tt>null</tt> may be passed if the value
                   returned by this parameter is not required.<DT><B>Returns:</B><DD><dd>RC>=0 - Cancel successful. RC is the number of users
                   having blocked operations cancelled.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADSID - <I>SidList</I> contains a bad
                   Sid. RetSid contains the invalid Sid.
                   <dd>XipcErr.SEM_ER_BADSIDLIST - Bad <I>SidList</I>.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemAccess("sem1");
                   int retcode = connection.SemCancel(Xipc.SemListBuild(sid1),
                   null);
                   </pre>
                   After logging in to an instance through an Xipc object, an
                   existing semaphore is accessed. Then SemCancel is called for
                   that single semaphore.  <tt>null</tt> is passed instead of an
                   XintRef object, since we are not interested in the value
                   returned via this parameter in this example.
                   All SemAcquire (if "sem1" is a resource semaphore) or SemWait
                   (if "sem1" is an event semaphore) operations blocked on
                   "sem1" are cancelled.</DL>
</DD>
</DL>
<HR>

<A NAME="SemClear(javaxipc30.SidList, javaxipc30.XintRef)"><!-- --></A><H3>
SemClear</H3>
<PRE>
public final int <B>SemClear</B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
                          <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid)</PRE>
<DL>
<DD>Clear event semaphores.
 SemClear() clears the semaphores specified in <I>SidList</I>.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>SidList</CODE> - A list of Sids to be cleared. This list should
                   be built by SemListBuild() and updated by SemListAdd().<DD><CODE>RetSid</CODE> - An XintRef object that gets assigned by
                   SemClear() on return. For failed calls, where return code
                   equals XipcErr.SEM_ER_BADSID or return code equals
                   XipcErr.SEM_ER_SEMCLEAR, <I>RetSid</I> contains the invalid
                   Sid. For successful calls <I>RetSid</I> contains the Sid of
                   the last semaphore cleared. In all other cases, the contents
                   of <I>RetSid</I> is undefined. <tt>null</tt> may be passed if
                   the value returned by this parameter is not required.<DT><B>Returns:</B><DD><dd>RC>=0 - Clear successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADSID - <I>SidList</I> contains a bad
                   Sid. <I>RetSid</I> contains the invalid Sid.
                   <dd>XipcErr.SEM_ER_BADSIDLIST - Bad <I>SidList</I>.
                   <dd>XipcErr.SEM_ER_CAPACITY - Internal capacity exceeded.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.SEM_ER_SEMCLEAR - <I>SidList</I> contains a Sid
                   of a semaphore which is already clear. <I>RetSid</I> contains
                   that Sid.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemCreate("event1", Xipc.SEM_SET);
                   int sid2 = connection.SemCreate("event2", Xipc.SEM_SET);
                   int retcode = connection.SemClear(new
                   SidList().SemListAdd(sid1).SemListAdd(sid2), null);
                   </pre>
                   After logging in to an instance through an Xipc object, two
                   event semaphores are created in the set state.
                   Then SemClear is used to change them from set to clear.  Note
                   that in this example the SidList is created with the methods
                   of class SidList, which are alternatives to the Xipc
                   SemListBuild and SemListAdd methods.</DL>
</DD>
</DL>
<HR>

<A NAME="SemCreate(java.lang.String, int)"><!-- --></A><H3>
SemCreate</H3>
<PRE>
public final int <B>SemCreate</B>(java.lang.String&nbsp;Name,
                           int&nbsp;CreateValue)</PRE>
<DL>
<DD>Create a new semaphore.
 SemCreate() creates a new semaphore in SemSys. <I>Name</I> is used for publicly
 identifying the new semaphore. A <I>Name</I> of SEM_PRIVATE directs SemSys to
 create a private semaphore (i.e. having no public identification).
 A resource semaphore is created having an initial value of <I>CreateValue</I>,
 while an event semaphore is created either as <I>set</I> or as <I>clear</I>.
 The method returns the Sid of the created semaphore.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Name</CODE> - A String that contains a symbolic name for
                   publicly identifying the semaphore. <I>Name</I> must not
                   exceed SEM_LEN_XIPCNAME characters. If <I>Name</I> is
                   SEM_PRIVATE then a private semaphore is created. Duplicate
                   semaphore names (other than SEM_PRIVATE) are illegal.<DD><CODE>CreateValue</CODE> - For resource semaphores, a non-zero
                   positive integer representing the semaphore's maximum value.
                   For event semaphores, either SEM_CLEAR or SEM_SET is
                   specified.<DT><B>Returns:</B><DD><dd>RC>=0 - Create successful. RC is semaphore ID (Sid). Sid
                   is to be used in all subsequent SemSys calls that refer to
                   this semaphore.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADSEMNAME - Invalid <I>Name</I>
                   parameter.
                   <dd>XipcErr.SEM_ER_BADSEMVALUE - Invalid <I>CreateValue</I>
                   parameter.
                   <dd>XipcErr.SEM_ER_CAPACITY - Internal capacity exceeded.
                   <dd>XipcErr.SEM_ER_DUPLICATE - Semaphore with <I>Name</I>
                   already exists.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemCreate("event1", Xipc.SEM_CLEAR);
                   int sid2 = connection.SemCreate("resource1", 5);
                   </pre>
                   A login is performed, and an event semaphore and a resource
                   semaphore are created.</DL>
</DD>
</DL>
<HR>

<A NAME="SemDelete(int)"><!-- --></A><H3>
SemDelete</H3>
<PRE>
public final int <B>SemDelete</B>(int&nbsp;Sid)</PRE>
<DL>
<DD>Delete a semaphore.
 SemDelete() deletes the semaphore identified by <I>Sid</I> from SemSys.
 SemDelete() will fail if any other users are holding onto or blocking for the
 specified semaphore.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Sid</CODE> - The semaphore ID of the semaphore to be deleted.
                   <I>Sid</I> was obtained by the user via SemCreate() or
                   SemAccess() method calls.<DT><B>Returns:</B><DD><dd>RC>=0 - Delete Successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADSID - No semaphore with <I>Sid</I>.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.SEM_ER_SEMBUSY - Semaphore <I>Sid</I> held or
                   blocked on by other users.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemAccess("sem1");
                   int retcode = connection.SemDelete(sid1);
                   </pre>
                   After logging in, an existing semaphore is accessed, and
                   SemDelete is used to delete it from the system.</DL>
</DD>
</DL>
<HR>

<A NAME="SemDestroy(int)"><!-- --></A><H3>
SemDestroy</H3>
<PRE>
public final int <B>SemDestroy</B>(int&nbsp;Sid)</PRE>
<DL>
<DD>Destroy a semaphore.
 SemDestroy() deletes the semaphore identified by <I>Sid</I> from SemSys even if
 other users are holding onto or blocked on the specified semaphore.
 Blocked SemAcquire() or SemWait() operations initiated by other users, having
 <I>Sid</I> as one of the semaphores being blocked on, are interrupted and
 returned with a return code equal to XipcErr.SEM_ER_DESTROYED, indicating the
 deletion of semaphore <I>Sid</I>. If <I>Sid</I> is a resource semaphore, its
 copies are silently taken away from users holding them. These users are not
 explicitly notified of the semaphore's deletion.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Sid</CODE> - The semaphore ID of the semaphore to be destroyed.
                   <I>Sid</I> was obtained by the user via SemCreate() or
                   SemAccess() method calls.<DT><B>Returns:</B><DD><dd>RC>=0 - Destroy successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADSID - No semaphore with specified<I>
                   Sid</I>.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemAccess("sem1");
                   int retcode = connection.SemDestroy(sid1);
                   </pre>
                   After logging in, an existing semaphore is accessed, and then
                   it is destroyed with SemDestroy.</DL>
</DD>
</DL>
<HR>

<A NAME="SemFreeze()"><!-- --></A><H3>
SemFreeze</H3>
<PRE>
public final int <B>SemFreeze</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="SemInfoSem(int, javaxipc30.SemInfoSem)"><!-- --></A><H3>
SemInfoSem</H3>
<PRE>
public final int <B>SemInfoSem</B>(int&nbsp;Sid,
                            <A HREF="../javaxipc30/SemInfoSem.html">SemInfoSem</A>&nbsp;InfoSem)</PRE>
<DL>
</DL>
<HR>

<A NAME="SemInfoSys(javaxipc30.SemInfoSys)"><!-- --></A><H3>
SemInfoSys</H3>
<PRE>
public final int <B>SemInfoSys</B>(<A HREF="../javaxipc30/SemInfoSys.html">SemInfoSys</A>&nbsp;InfoSys)</PRE>
<DL>
</DL>
<HR>

<A NAME="SemInfoUser(int, javaxipc30.SemInfoUser)"><!-- --></A><H3>
SemInfoUser</H3>
<PRE>
public final int <B>SemInfoUser</B>(int&nbsp;Uid,
                             <A HREF="../javaxipc30/SemInfoUser.html">SemInfoUser</A>&nbsp;InfoUser)</PRE>
<DL>
</DL>
<HR>

<A NAME="SemListBuild(int)"><!-- --></A><H3>
SemListBuild</H3>
<PRE>
public static final <A HREF="../javaxipc30/SidList.html">SidList</A> <B>SemListBuild</B>(int&nbsp;Sid)</PRE>
<DL>
<DD>Build a new SidList containing a single Sid.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Sid</CODE> - An integer semaphore id to be included in the
                   resultant SidList.<DT><B>Returns:</B><DD>A new SidList containing the single specified semaphore id.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemAccess("resource1");
                   SidList sl = Xipc.SemListBuild(sid1);
                   </pre>
                   After logging in, an existing semaphore is accessed and a
                   SidList is built containing it's semaphore id.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/SidList.html"><CODE>SidList</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="SemListAdd(javaxipc30.SidList, int)"><!-- --></A><H3>
SemListAdd</H3>
<PRE>
public static final <A HREF="../javaxipc30/SidList.html">SidList</A> <B>SemListAdd</B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
                                       int&nbsp;Sid)</PRE>
<DL>
<DD>Add a Sid to an existing SidList.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>SidList</CODE> - A SidList object that is to be updated.<DD><CODE>Sid</CODE> - An integer semaphore id.<DT><B>Returns:</B><DD><dd>RC!=<TT>null</TT> - The SidList passed as an argument,
                   updated to include Sid.
                   <dd>RC=<TT>null</TT> - Error: <I>SidList</I> exceeded
                   SEM_LEN_SIDLIST elements.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemAccess("sem1");
                   int sid2 = connection.SemAccess("sem2");
                   int sid3 = connection.SemAccess("sem3");
                   SidList sl = Xipc.SemListBuild(sid1);
                   Xipc.SemListAdd(sl, sid2);
                   Xipc.SemListAdd(sl, sid3);
                   </pre>
                   After logging in, three existing semaphores are accessed.	A
                   SidList is created containing the sid of one of these, then
                   the sids of the other two are added using SemListAdd.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/SidList.html"><CODE>SidList</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="SemRelease(javaxipc30.SidList, javaxipc30.XintRef)"><!-- --></A><H3>
SemRelease</H3>
<PRE>
public final int <B>SemRelease</B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
                            <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid)</PRE>
<DL>
<DD>Release resource semaphores.
 SemRelease() releases the resource semaphores specified in <I>SidList</I>.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>SidList</CODE> - A list of Sids being released. This list can
                   be built by SemListBuild() and updated by SemListAdd().<DD><CODE>RetSid</CODE> - An XintRef object that gets assigned by
                   SemRelease() on return. For failed calls, where return code
                   equals XipcErr.SEM_ER_BADSID or return code equals
                   XipcErr.SEM_ER_SEMNOTHELD, <I>RetSid</I> contains the invalid
                   Sid. For successful calls <I>RetSid</I> contains the last
                   semaphore released. In all other cases, the contents of
                   <I>RetSid</I> is undefined. <tt>null</tt> may be passed if
                   the value returned by this parameter is not required.<DT><B>Returns:</B><DD><dd>RC>=0 - Release successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADSID - <I>SidList</I> contains a bad
                   Sid. RetSid contains the invalid Sid.
                   <dd>XipcErr.SEM_ER_BADSIDLIST - Bad <I>SidList</I>.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.SEM_ER_SEMNOTHELD - <I>SidList</I> contains a Sid
                   of a semaphore not currently held by the user. <I>RetSid</I>
                   contains that Sid.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemAccess("resource1");
                   int sid2 = connection.SemAccess("resource2");
                   SidList sl = Xipc.SemListBuild(sid1);
                   Xipc.SemListAdd(sl, sid2);
                   XintRef retsid = new XintRef(-1);
                   int retcode = connection.SemAcquire(Xipc.SEM_ANY, sl, retsid,
                   Xipc.SEM_WAIT);
                   sl = Xipc.SemListBuild(retsid.getValue());
                   retcode = connection.SemRelease(sl, null);
                   </pre>
                   After logging in to an instance through an Xipc object, two
                   existing resource semaphores are accessed, and their sid's
                   are put into a SidList. SemAcquire is used to acquire either
                   of the resoures, and then the acquired resource is released
                   using SemRelease.</DL>
</DD>
</DL>
<HR>

<A NAME="SemSet(javaxipc30.SidList, javaxipc30.XintRef)"><!-- --></A><H3>
SemSet</H3>
<PRE>
public final int <B>SemSet</B>(<A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
                        <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid)</PRE>
<DL>
<DD>Set event semaphores.
 SemSet() sets the semaphores specified in <I>SidList</I>.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>SidList</CODE> - A list of Sids to be Set. This list should be
                   built by SemList() or SemListBuild() and updated by
                   SemListAdd().<DD><CODE>RetSid</CODE> - An XintRef object that gets assigned by
                   SemSet() on return. For failed calls, where return code
                   equals XipcErr.SEM_ER_BADSID or return code equals
                   XipcErr.SEM_ER_SEMSET, <I>RetSid</I> contains the invalid
                   Sid. For successful calls <I>RetSid</I> contains the last
                   semaphore set. In all other cases, the contents of
                   <I>RetSid</I> is undefined. <tt>null</tt> may be passed if
                   the value returned by this parameter is not required.<DT><B>Returns:</B><DD><dd>RC>=0 - Set successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADSID - <I>SidList</I> contains a bad
                   Sid. RetSid contains the invalid Sid.
                   <dd>XipcErr.SEM_ER_BADSIDLIST -Bad <I>SidList</I>.
                   <dd>XipcErr.SEM_ER_CAPACITY - Internal capacity exceeded.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.SEM_ER_SEMSET - <I>SidList</I> contains a Sid of
                   a semaphore which is already set. <I>RetSid</I> contains that
                   Sid.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemCreate("event1", Xipc.SEM_CLEAR);
                   int sid2 = connection.SemCreate("event2", Xipc.SEM_CLEAR);
                   SidList sl = new SidList();
                   sl.SemListAdd(sid1).SemListAdd(sid2);
                   int retcode = connection.SemSet(sl, null);
                   </pre>
                   After logging in to an instance through an Xipc object, two
                   event semaphores are created in the clear state.
                   Then SemSet is used to change them from clear to set.  Note
                   that in this example the SidList is created with the methods
                   of class SidList, which are alternatives to the Xipc
                   SemListBuild and SemListAdd methods.</DL>
</DD>
</DL>
<HR>

<A NAME="SemUnfreeze()"><!-- --></A><H3>
SemUnfreeze</H3>
<PRE>
public final int <B>SemUnfreeze</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="SemWait(int, javaxipc30.SidList, javaxipc30.XintRef, int)"><!-- --></A><H3>
SemWait</H3>
<PRE>
public final int <B>SemWait</B>(int&nbsp;WaitType,
                         <A HREF="../javaxipc30/SidList.html">SidList</A>&nbsp;SidList,
                         <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetSid,
                         int&nbsp;BlockOpt)</PRE>
<DL>
<DD>Wait on event semaphores.
 SemWait() waits for the semaphores in <I>SidList</I> to be in a set state,
 based on the values of <I>WaitType</I> and <I>BlockOpt</I>.
 <P>The value of <I>WaitType</I> specifies how to satisfy the requested wait:
 <UL>
 <LI>If <I>WaitType</I> = SEM_ANY, the request is considered satisfied when any
 one of the semaphores in <I>SidList</I> is in the set state. </LI>
 <LI>If <I>WaitType</I> = SEM_ALL, the request is not considered satisfied until
 all the semaphores in <I>SidList</I> have been in the set state at least once
 since the beginning of the wait. Semaphore states are noted as they become set
 until the entire <I>SidList</I> has been set. If a semaphore that was noted to
 be set changes its state to clear before the wait is satisfied, the change will
 not affect the satisfaction of the wait. </LI>
 <LI>If <I>WaitType</I> = SEM_ATOMIC, the request is not considered satisfied
 until all the semaphores in <I>SidList</I> are in the set state at one time.
 Semaphore states are noted as they become set until the entire <I>SidList</I>
 has been set. If a semaphore that was noted to be set changes its state to
 clear before the wait is satisfied, the change will be noted and will prevent
 the wait from being satisfied. In this way it differs from<I> WaitType</I>
 = SEM_ALL. </LI>
 </UL>
 <P>Satisfied SemWait() calls return with RetSid containing the Sid of te last
 semaphore to be set.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>WaitType</CODE> - SEM_ANY, SEM_ALL or SEM_ATOMIC depending on
                   the waiting criteria desired.<DD><CODE>SidList</CODE> - A list of Sids being waited on. This list
                   should be a SidList built by SemList() or SemListBuild() and
                   updated by SemListAdd().<DD><CODE>RetSid</CODE> - An XintRef object that gets assigned by
                   SemWait() upon its return. Successful wait operations
                   (RC&gt;=0) return with RetSid containing the last Sid to be
                   set. Interrupted wait operations (return code equals
                   XipcErr.SEM_ER_DESTROYED or XipcErr.SEM_ER_CANCEL) return
                   with RetSid containing the destroyed or cancelled Sid. Failed
                   calls with return code equals XipcErr.SEM_ER_BADSID return
                   with RetSid containing the invalid Sid. The contents of
                   RetSid is otherwise undefined. <tt>null</tt> may be passed if
                   the value returned by this parameter is not required.<DD><CODE>BlockOpt</CODE> - One of SEM_WAIT, SEM_NOWAIT or
                   SEM_TIMEOUT(t), optionally combined with SEM_CLEAR by using a
                   bitwise or (ex: <TT>SEM_CLEAR|SEM_TIMEOUT(10)</TT>). Or-ing
                   SEM_CLEAR with the blocking option indicates that semaphores
                   are to be cleared at the successful completion of the SemWait
                   operation. See <A HREF="XipcBlockingOption.html">blocking
                   option parameter</A> for more information.<DT><B>Returns:</B><DD><dd>RC>=0 - Wait successful. If <I>WaitType</I> = SEM_ANY
                   then one of the requested semaphores has been set and RetSid
                   contains the Sid of that semaphore. If <I>WaitType</I> =
                   SEM_ALL or SEM_ATOMIC then all requested semaphores have been
                   set and RetSid contains the Sid of the last semaphore set.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.SEM_ER_BADBLOCKOPT - Invalid <I>BlockOpt</I>.
                   <dd>XipcErr.SEM_ER_BADCLEAROPT - Invalid <I>ClearOpt</I>.
                   <dd>XipcErr.SEM_ER_BADOPTION - Invalid <I>BlockOpt</I>
                   parameter.
                   <dd>XipcErr.SEM_ER_BADSID - <I>SidList</I> contains a bad
                   Sid. RetSid contains the invalid Sid.
                   <dd>XipcErr.SEM_ER_BADSIDLIST - Bad <I>SidList</I>.
                   <dd>XipcErr.SEM_ER_BADWAITTYPE - Invalid <I>WaitType</I>
                   parameter.
                   <dd>XipcErr.SEM_ER_CANCEL - Another user issued a SemCancel()
                   call for one of the semaphores in <I>SidList</I>. The blocked
                   SemWait() operation was cancelled.<I>
                   RetSid</I> contains the Sid of the semaphore for which the
                   SemCancel() was issued.
                   <dd>XipcErr.SEM_ER_CAPACITY - Internal capacity exceeded.
                   <dd>XipcErr.SEM_ER_DESTROYED - Another user destroyed a
                   semaphore that was being waited on by this user. The blocked
                   acquire operation was cancelled. RetSid contains the Sid of
                   the destroyed semaphore.
                   <dd>XipcErr.SEM_ER_NOSUBSYSTEM - SemSys is not configured in
                   the instance.
                   <dd>XipcErr.SEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.SEM_ER_NOWAIT - <I>BlockOpt</I> of SEM_NOWAIT was
                   specified and the request was not immediately satisfied.
                   <dd>XipcErr.SEM_ER_TIMEOUT - The time out period for the
                   blocked wait operation has expired without satisfying the
                   request.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int sid1 = connection.SemAccess("event1");
                   int sid2 = connection.SemAccess("event2");
                   SidList sl = Xipc.SemListBuild(sid1);
                   Xipc.SemListAdd(sl, sid2);
                   XintRef retsid = new XintRef(-1);
                   int retcode = connection.SemWait(Xipc.SEM_ANY, sl, retsid,
                   Xipc.SEM_CLEAR|Xipc.SEM_WAIT);
                   int event = retsid.getValue();
                   if (event == sid1)
                   System.out.println("event1 occurred");
                   else
                   System.out.println("event2 occurred");
                   </pre>
                   After logging in to an instance through an Xipc object, two
                   existing event semaphores are accessed, and their sid's are
                   put into a SidList. SemWait is performed to wait until either
                   semaphore becomes set (the SEM_CLEAR option will cause it to
                   be cleared again).
                   A message is printed indicating which event semaphore became
                   set.</DL>
</DD>
</DL>
<HR>

<A NAME="QueAccess(java.lang.String)"><!-- --></A><H3>
QueAccess</H3>
<PRE>
public int <B>QueAccess</B>(java.lang.String&nbsp;Name)</PRE>
<DL>
<DD>Access an existing queue.
 QueAccess() accesses an existing queue in QueSys. <I>Name</I> is used for
 identifying the desired queue. The method returns the Qid of the accessed
 queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Name</CODE> - A pointer to a string that contains the symbolic
                   name identifying the desired queue. The <I>Name</I> must be
                   null terminated, must not exceed QUE_LEN_XIPCNAME characters,
                   must identify an existing queue and cannot be QUE_PRIVATE.<DT><B>Returns:</B><DD><dd>RC>=0 - Access successful. RC is Queue ID (Qid). Qid is
                   to be used in all subsequent QueSys calls that refer to this
                   queue.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.QUE_ER_BADQUENAME - Invalid <I>Name</I>
                   parameter.
                   <dd>XipcErr.QUE_ER_NOSUBSYSTEM - QueSys is not configured in
                   the instance.
                   <dd>XipcErr.QUE_ER_NOTFOUND - Queue with <I>Name</I> does not
                   exist.
                   <dd>XipcErr.QUE_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int qid1 = connection.QueCreate("queue1", 10,
                   Xipc.QUE_NOLIMIT);
                   if (qid1 == XipcErr.QUE_ER_DUPLICATE) qid1 =
                   connection.QueAccess("queue1");
                   </pre>
                   After logging in to an instance through an Xipc object, an
                   attempt is made to create a queue with the name "queue1".
                   If the return code indicates that a queue with that name
                   already exists, then QueAccess is used to get it's queue id.</DL>
</DD>
</DL>
<HR>

<A NAME="QueBrowse(javaxipc30.MsgHdr, int)"><!-- --></A><H3>
QueBrowse</H3>
<PRE>
public final int <B>QueBrowse</B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
                           int&nbsp;Direction)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueCopy(javaxipc30.MsgHdr, int, int, byte[])"><!-- --></A><H3>
QueCopy</H3>
<PRE>
public final int <B>QueCopy</B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
                         int&nbsp;offset,
                         int&nbsp;length,
                         byte[]&nbsp;buffer)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueCreate(java.lang.String, int, int)"><!-- --></A><H3>
QueCreate</H3>
<PRE>
public final int <B>QueCreate</B>(java.lang.String&nbsp;Name,
                           int&nbsp;LimitMsgs,
                           int&nbsp;LimitBytes)</PRE>
<DL>
<DD>Create a new queue.
 QueCreate() creates a new queue in QueSys. <I>Name</I> is used for publicly
 identifying the new queue. A <I>Name</I> of QUE_PRIVATE directs QueSys to
 create a private queue (i.e. having no public name). The method returns the Qid
 of the created queue.
 <P>The queue is created with the capacity to hold up to a maximum of
 <I>LimitMsgs</I>
 messages and <I>LimitBytes</I> bytes, whichever limit occurs first. Setting
 both limits to QUE_NOLIMIT creates a queue which has no enforced size
 limitation, and will accept messages until overall instance limitations are
 encountered (e.g. headers, text pool space, etc.).
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Name</CODE> - A String that contains a symbolic name for
                   publicly identifying the created queue. The <I>Name</I> must
                   not exceed QUE_LEN_XIPCNAME characters. If <I>Name</I> is
                   QUE_PRIVATE then a private queue is created. Duplicate queue
                   names (other than QUE_PRIVATE) are not allowed.<DD><CODE>LimitMsgs</CODE> - The maximum number of messages that can
                   reside on the queue at any one time. A value of QUE_NOLIMIT
                   indicates that no limit is to be enforced on the number of
                   messages allowed on the queue.<DD><CODE>LimitBytes</CODE> - The maximum number of message text bytes
                   that can reside on the queue at any one time. A value of
                   QUE_NOLIMIT indicates that no limit is to be enforced on the
                   number of message text bytes allowed on the queue.<DT><B>Returns:</B><DD><dd>RC>=0 - Create successful. RC is Queue ID (Qid). Qid is
                   to be used in all subsequent QueSys calls that refer to this
                   queue.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.QUE_ER_BADLIMIT - Invalid <I>LimitMsgs </I>or<I>
                   LimitBytes </I>parameter.
                   <dd>XipcErr.QUE_ER_BADQUENAME - Invalid <I>Name</I>
                   parameter.
                   <dd>XipcErr.QUE_ER_CAPACITY - QueSys internal system capacity
                   has been reached.
                   <dd>XipcErr.QUE_ER_DUPLICATE - Queue with <I>Name</I> already
                   exists.
                   <dd>XipcErr.QUE_ER_NOSUBSYSTEM - QueSys is not configured in
                   the instance.
                   <dd>XipcErr.QUE_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int qid = connection.QueCreate("queue1", 5,
                   Xipc.QUE_NOLIMIT);
                   </pre>
                   A login is performed, and a queue is created with name
                   "queue1", and a limit of 5 messages and no set limit on total
                   number of bytes.	The queues id is placed in <tt>qid</tt>.</DL>
</DD>
</DL>
<HR>

<A NAME="QueDelete(int)"><!-- --></A><H3>
QueDelete</H3>
<PRE>
public final int <B>QueDelete</B>(int&nbsp;Qid)</PRE>
<DL>
<DD>Delete a queue.
 QueDelete() deletes the Queue identified by <I>Qid</I> from QueSys.
 QueDelete() will fail if the specified queue is not empty, or if any users are
 waiting to dispatch or retrieve messages via queue <I>Qid</I>.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - The Queue ID of the queue to be deleted.
                   <I>Qid</I> was obtained by the user via QueCreate() or
                   QueAccess() method calls.<DT><B>Returns:</B><DD><dd>RC>=0 - Delete successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.QUE_ER_BADQID - No queue with <I>Qid</I>.
                   <dd>XipcErr.QUE_ER_NOSUBSYSTEM - QueSys is not configured in
                   the instance.
                   <dd>XipcErr.QUE_ER_NOTEMPTY - The queue is not empty.
                   <dd>XipcErr.QUE_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.QUE_ER_WAITEDON - A user is waiting for a message
                   on <I>Qid</I>.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int qid1 = connection.QueAccess("queue1");
                   int retcode = connection.QueDelete(qid1);
                   </pre>
                   After logging in, an existing queue is accessed, and
                   QueDelete is used to delete it from the system.</DL>
</DD>
</DL>
<HR>

<A NAME="QueDestroy(int)"><!-- --></A><H3>
QueDestroy</H3>
<PRE>
public final int <B>QueDestroy</B>(int&nbsp;Qid)</PRE>
<DL>
<DD>Destroy a queue.
 QueDestroy() removes the Queue identified by <I>Qid</I> from QueSys regardless
 of whether it has messages on it, or that other users are waiting to send or
 receive messages via the queue. Messages residing on the queue are silently
 destroyed. Users blocked on QueSys calls involving queue <I>Qid</I>
 (such as QueSend(), QueReceive(), QuePut() or QueGet()) are interrupted and
 returned an error code of XipcErr.QUE_ER_DESTROYED indicating the removal of
 queue <I>Qid</I> from QueSys.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - The Queue ID of the queue to be destroyed.
                   <I>Qid</I> was obtained by the user via QueCreate() or
                   QueAccess() method calls.<DT><B>Returns:</B><DD><dd>RC>=0 - Destroy successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.QUE_ER_BADQID - No queue with <I>Qid</I>.
                   <dd>XipcErr.QUE_ER_NOSUBSYSTEM - QueSys is not configured in
                   the instance.
                   <dd>XipcErr.QUE_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int qid1 = connection.QueAccess("queue1");
                   int retcode = connection.QueDestroy(qid1);
                   </pre>
                   After logging in, an existing queue is accessed, and then it
                   is destroyed with QueDestroy.</DL>
</DD>
</DL>
<HR>

<A NAME="QueFreeze()"><!-- --></A><H3>
QueFreeze</H3>
<PRE>
public final int <B>QueFreeze</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="QueGet(javaxipc30.MsgHdr, int, javaxipc30.QidList, javaxipc30.XintRef, javaxipc30.XintRef, int)"><!-- --></A><H3>
QueGet</H3>
<PRE>
public final int <B>QueGet</B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
                        int&nbsp;QueSelectCode,
                        <A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;qidList,
                        <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetPrio,
                        <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetQid,
                        int&nbsp;BlockOpt)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueInfoQue(int, javaxipc30.QueInfoQue)"><!-- --></A><H3>
QueInfoQue</H3>
<PRE>
public final int <B>QueInfoQue</B>(int&nbsp;Qid,
                            <A HREF="../javaxipc30/QueInfoQue.html">QueInfoQue</A>&nbsp;InfoQue)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueInfoSys(javaxipc30.QueInfoSys)"><!-- --></A><H3>
QueInfoSys</H3>
<PRE>
public final int <B>QueInfoSys</B>(<A HREF="../javaxipc30/QueInfoSys.html">QueInfoSys</A>&nbsp;InfoSys)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueInfoUser(int, javaxipc30.QueInfoUser)"><!-- --></A><H3>
QueInfoUser</H3>
<PRE>
public final int <B>QueInfoUser</B>(int&nbsp;Uid,
                             <A HREF="../javaxipc30/QueInfoUser.html">QueInfoUser</A>&nbsp;InfoUser)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueListBuild(int)"><!-- --></A><H3>
QueListBuild</H3>
<PRE>
public static final <A HREF="../javaxipc30/QidList.html">QidList</A> <B>QueListBuild</B>(int&nbsp;Qid)</PRE>
<DL>
<DD>Build a new QidList containing a single Qid.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id to be included in the
                   resultant QidList.<DT><B>Returns:</B><DD><dd>RC!=<TT>null</TT> - A new QidList containing the single
                   specified Qid.
                   <dd>RC=<TT>null</TT> - Error: <I>QidList</I> exceeded
                   QUE_LEN_QIDLIST elements.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int qid1 = connection.QueAccess("queue1");
                   QidList ql = Xipc.QueListBuild(qid1);
                   </pre>
                   After logging in, an existing queue is accessed and a QidList
                   is built containing it's queue id.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/QidList.html"><CODE>QidList</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QueListBuild(javaxipc30.MsgSelectQid)"><!-- --></A><H3>
QueListBuild</H3>
<PRE>
public static final <A HREF="../javaxipc30/QidList.html">QidList</A> <B>QueListBuild</B>(<A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A>&nbsp;MSQid)</PRE>
<DL>
<DD>Build a new QidList containing a single Qid with message select code.
 See section on <A HREF="XipcSelectCodes.html">Queue and Message Select
 Codes</A> for more information on message select codes.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>MSQid</CODE> - An integer queue id, with a message select code
                   method applied, to be included in the resultant QidList.<DT><B>Returns:</B><DD><dd>RC!=<TT>null</TT> - A new QidList containing the single
                   specified Qid id with message select code.
                   <dd>RC=<TT>null</TT> - Error: <I>QidList</I> exceeded
                   QUE_LEN_QIDLIST elements.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int qid1 = connection.QueAccess("queue1");
                   QidList ql =
                   Xipc.QueListBuild(Xipc.QUE_M_PRRNG(qid1,100,200));
                   </pre>
                   After logging in, an existing queue is accessed and a QidList
                   is built containing it's queue id, with the message select
                   code for selecting a candidate message having a priority in
                   the range [100,200].
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/QidList.html"><CODE>QidList</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QueListAdd(javaxipc30.QidList, int)"><!-- --></A><H3>
QueListAdd</H3>
<PRE>
public static final <A HREF="../javaxipc30/QidList.html">QidList</A> <B>QueListAdd</B>(<A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;QidList,
                                       int&nbsp;Qid)</PRE>
<DL>
<DD>Add a Qid to an existing QidList.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>QidList</CODE> - A QidList object that is to be updated.<DD><CODE>Qid</CODE> - An integer queue id.<DT><B>Returns:</B><DD><dd>RC!=<TT>null</TT> - The QidList passed as an argument,
                   updated to include Qid.
                   <dd>RC=<TT>null</TT> - Error: <I>QidList</I> exceeded
                   QUE_LEN_QIDLIST elements.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int qid1 = connection.QueAccess("queue1");
                   int qid2 = connection.QueAccess("queue2");
                   int qid3 = connection.QueAccess("queue3");
                   QidList ql = Xipc.QueListBuild(qid1);
                   Xipc.QueListAdd(ql, qid2);
                   Xipc.QueListAdd(ql, qid3);
                   </pre>
                   After logging in, three existing queues are accessed.  A
                   QidList is created containing the qid of one of these, then
                   the qids of the other two are added using QueListAdd.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/QidList.html"><CODE>QidList</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QueListAdd(javaxipc30.QidList, javaxipc30.MsgSelectQid)"><!-- --></A><H3>
QueListAdd</H3>
<PRE>
public static final <A HREF="../javaxipc30/QidList.html">QidList</A> <B>QueListAdd</B>(<A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;QidList,
                                       <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A>&nbsp;MSQid)</PRE>
<DL>
<DD>Add a Qid with a message select code to an existing QidList.
 See section on <A HREF="XipcSelectCodes.html">Queue and Message Select
 Codes</A> for more information on message select codes.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>QidList</CODE> - A QidList object that is to be updated.<DD><CODE>MSQid</CODE> - An integer queue id, with a message select code
                   method applied, to be added to the QidList.<DT><B>Returns:</B><DD><dd>RC!=<TT>null</TT> - The QidList passed as an argument,
                   updated to include Qid with message select code.
                   <dd>RC=<TT>null</TT> - Error: <I>QidList</I> exceeded
                   QUE_LEN_QIDLIST elements.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int qid1 = connection.QueAccess("queue1");
                   int qid2 = connection.QueAccess("queue2");
                   int qid3 = connection.QueAccess("queue3");
                   QidList ql = Xipc.QueListBuild(Xipc.QUE_M_EA(qid1));
                   Xipc.QueListAdd(ql, Xipc.QUE_M_HP(qid2));
                   Xipc.QueListAdd(ql, Xipc.QUE_M_LP(qid3));
                   </pre>
                   After logging in, three existing queues are accessed.  A
                   QidList is created for message retrieval, selecting as
                   candidate messages the earliest arrived message from queue1,
                   the highest priority message from queue2, and the lowest
                   priority message from queue3.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/QidList.html"><CODE>QidList</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QueMsgHdrDup(javaxipc30.MsgHdr, javaxipc30.MsgHdr)"><!-- --></A><H3>
QueMsgHdrDup</H3>
<PRE>
public final int <B>QueMsgHdrDup</B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;existingMsgHdr,
                              <A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;newMsgHdr)</PRE>
<DL>
</DL>
<HR>

<A NAME="QuePurge(int)"><!-- --></A><H3>
QuePurge</H3>
<PRE>
public final int <B>QuePurge</B>(int&nbsp;Qid)</PRE>
<DL>
</DL>
<HR>

<A NAME="QuePut(javaxipc30.MsgHdr, int, javaxipc30.QidList, int, javaxipc30.XintRef, int)"><!-- --></A><H3>
QuePut</H3>
<PRE>
public final int <B>QuePut</B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
                        int&nbsp;QueSelectCode,
                        <A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;qidList,
                        int&nbsp;Priority,
                        <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetQid,
                        int&nbsp;BlockOpt)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueRead(javaxipc30.MsgHdr, byte[], int)"><!-- --></A><H3>
QueRead</H3>
<PRE>
public final int <B>QueRead</B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
                         byte[]&nbsp;MsgBuf,
                         int&nbsp;MsgLength)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><!-- --></A><H3>
QueReceive</H3>
<PRE>
public final int <B>QueReceive</B>(int&nbsp;QueSelectCode,
                            <A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;QidList,
                            byte[]&nbsp;MsgBuf,
                            int&nbsp;MsgLength,
                            <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetPrio,
                            <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetQid,
                            int&nbsp;BlockOpt)</PRE>
<DL>
<DD>Receive and read a message from a queue.
 QueReceive() attempts to receive a QueSys message from one of the Qids in
 <I>QidList</I>. The determination of which message is received is based on each
 Qid's Message Select Code as listed in <I>QidList</I>, in conjunction with the
 value of <I>QueSelectCode</I>.
 See section on <A HREF="XipcSelectCodes.html">Queue and Message Select
 Codes</A> for more information on message select codes and queue select codes.
 QueReceive() first attempts to access the chosen message header, and remove it
 from its queue. It then reads the text of the message from the message text
 pool into the buffer pointed at by <I>MsgBuf</I>. <I>RetPrio</I> is assigned
 with the retrieved message's priority. The message's text pool area is then
 released.
 <P>If the size of the selected message is less than or equal to
 <I>MsgLength</I>
 bytes, the message is copied in its entirety into <I>MsgBuf</I>. If the message
 size is larger, then:
 <UL>
 <LI>If QUE_TRUNCATE(<I>MsgLength</I>) is specified, the first <I>MsgLength</I>
 bytes of the message are copied into <I>MsgBuf</I>. The remaining bytes are
 truncated and lost. </LI>
 <LI>Otherwise, QueReceive() fails, with return code equal to
 XipcErr.QUE_ER_TOOBIG and the message remains in the queue. </LI>
 </UL>
 <P>QueReceive() is given the potential to block by setting <I>BlockOpt</I>
 appropriately. The operation will block if either all the listed queues are
 empty, or contain messages not matching their respective Message Select Codes.
 A QueReceive() operation will complete when the cause of it not completing is
 removed, usually by another user's actions. Specifically:
 <UL>
 <LI>Another user calling QueSend() or QuePut() to place a message on one of the
 involved queues. </LI>
 </UL>
 <P>See <A HREF="XipcBlockingOption.html">blocking option parameter</A> for
 further information on using blocking options.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>QueSelectCode</CODE> - A code indicating the selection criteria
                   to be used in determining the received message of the
                   QueReceive() operation. The selected message is taken from
                   one of the Qids in <I>QidList</I>. The possible values for
                   <I>QueSelectCode</I> in a QueSend operation are listed and
                   explained in <A HREF="XipcSelectCodes.html">Queue and Message
                   Select Codes</A>.<DD><CODE>QidList</CODE> - A list of Qids, possibly specified within
                   Message Select Code macros, to be used in specifying
                   candidate messages for consideration by the QueReceive()
                   operation. QueReceive() selects one of the candidate messages
                   based on the value of <I>QueSelectCode</I>. A QidList is
                   constructed using QueList() or QueListBuild() and is updated
                   using QueListAdd().<DD><CODE>MsgBuf</CODE> - An array of bytes to serve as a message buffer
                   to receive the message text.<DD><CODE>MsgLength</CODE> - An integer specifying the maximum number of
                   bytes to be copied from the retrieved message into
                   <I>MsgBuf</I>. QUE_TRUNCATE(<I>MsgLength</I>) must be
                   specified if text truncation is desired for messages
                   exceeding bytes in size. <I>MsgLength</I> must be greater
                   than 0, and not greater than the length of <I>MsgBuf</I>.<DD><CODE>RetPrio</CODE> - An <I>XintRef</I> object that gets assigned
                   with the received message's priority. <TT>null</TT> may be
                   used if the priority value is not needed.<DD><CODE>RetQid</CODE> - An XintRef object that gets assigned by
                   QueReceive() upon its return. Successful QueReceive()
                   operations (RC>= 0) return with RetQid containing the Qid of
                   the selected source queue (from within QidList) that provided
                   the received message. Cancelled QueReceive() operations
                   having return code equal to XipcErr.QUE_ER_DESTROYED or
                   XipcErr.QUE_ER_PURGED, return with RetQid containing the
                   destroyed or purged Qid. Failed calls with return code equal
                   to XipcErr.QUE_ER_BADQID return with RetQid containing the
                   invalid Qid. The contents of RetQid is otherwise undefined.
                   <tt>null</tt> may be passed if the value returned by this
                   parameter is not required.<DD><CODE>BlockOpt</CODE> - One of QUE_WAIT, QUE_NOWAIT or QUE_TIMEOUT(t)
                   for an integer t. See <A
                   HREF="XipcBlockingOption.html">blocking option parameter</A>
                   for further information.<DT><B>Returns:</B><DD><dd>RC>=0 - Receive successful. RC is the number of bytes
                   copied into <I>MsgBuf</I>.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.QUE_ER_BADBLOCKOPT - Invalid <I>BlockOpt</I>.
                   <dd>XipcErr.QUE_ER_BADBUFFER - <I>MsgBuf</I> is NULL.
                   <dd>XipcErr.QUE_ER_BADLENGTH - Invalid <I>MsgLength</I>
                   parameter.
                   <dd>XipcErr.QUE_ER_BADMSGSELECTCODE - Invalid MsgSelectCode
                   within <I>QidList</I>.
                   <dd>XipcErr.QUE_ER_BADOPTION - Invalid <I>BlockOpt</I>
                   parameter.
                   <dd>XipcErr.QUE_ER_BADQID - Bad Qid in QidList (it's value is
                   in <I>RetQid</I>).
                   <dd>XipcErr.QUE_ER_BADQIDLIST - Invalid QidList parameter.
                   <dd>XipcErr.QUE_ER_BADQUESELECTCODE - Invalid QueSelectCode
                   parameter.
                   <dd>XipcErr.QUE_ER_CAPACITY - QueSys internal system capacity
                   error.
                   <dd>XipcErr.QUE_ER_DESTROYED - Another user destroyed a queue
                   that the blocked QueReceive() call was waiting on. The
                   blocked QueReceive() operation was cancelled.
                   No message was received.
                   <dd>XipcErr.QUE_ER_NOSUBSYSTEM - QueSys is not configured in
                   the instance.
                   <dd>XipcErr.QUE_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.QUE_ER_NOWAIT - <I>BlockOpt</I> of QUE_NOWAIT was
                   specified and request was not immediately satisfied.
                   <dd>XipcErr.QUE_ER_PURGED - Another user purged a queue that
                   the blocked QueReceive() call was waiting on. The blocked
                   QueReceive() operation was cancelled.
                   No message was received.
                   <dd>XipcErr.QUE_ER_TIMEOUT - The blocked QueReceive()
                   operation timed out.
                   <dd>XipcErr.QUE_ER_TOOBIG - The size of the message exceeds
                   <I>MsgLength</I> and QUE_TRUNCATE was not specified.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <dd>XipcErr.XIPCNET_ER_TOOBIG - Message text exceeds
                   instance's size limit.
                   <p>
                   <A NAME="QueReceive Example"><dt><b>Example:</b></A>
                   <dd><pre>
                   Xipc cnnct = new Xipc();
                   byte[] buf = new byte[80];
                   int uid = cnnct.XipcLogin("@server:NetInstance", "user");
                   int qid1 = cnnct.QueAccess("queue1");
                   int qid2 = cnnct.QueAccess("queue2");
                   int qid3 = cnnct.QueAccess("queue3");
                   QidList ql = Xipc.QueListBuild(Xipc.QUE_M_EA(qid1));
                   Xipc.QueListAdd(ql, Xipc.QUE_M_EA(qid2));
                   Xipc.QueListAdd(ql, Xipc.QUE_M_EA(qid3));
                   XintRef retPri = new XintRef(-1);
                   XintRef retQid = new XintRef(-1);
                   int rc = cnnct.QueReceive(Xipc.QUE_Q_LNQ, ql, buf,
                   Xipc.QUE_TRUNCATE(80), retPri, retQid, Xipc.QUE_WAIT);
                   String msg = new String(buf, 0, 0, rc);
                   System.out.println("message was: " + msg);
                   System.out.println("priority = " + retPri.getValue());
                   System.out.println("received from queue with qid = " +
                   retQid.getValue());
                   </pre>
                   An Xipc object is created, and a login is performed.
                   Three queues are accessed, and a QidList is created with
                   message select codes selecting as candidate messages the
                   highest priority message on each queue.
                   Then the candidate message from the longest queue in the
                   QidList is received into the buffer, truncating it if
                   neccessary.  The message is converted to a string and
                   printed, along with it's priority and the queue id of the
                   queue it was received from.</DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_HP(int)"><!-- --></A><H3>
QUE_M_HP</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_HP</B>(int&nbsp;Qid)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the <I>highest priority</I> message as the candidate message from the
 specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_LP(int)"><!-- --></A><H3>
QUE_M_LP</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_LP</B>(int&nbsp;Qid)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the <I>lowest priority</I> message as the candidate message from the
 specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_EA(int)"><!-- --></A><H3>
QUE_M_EA</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_EA</B>(int&nbsp;Qid)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the <I>earliest arrived</I> message as the candidate message from the
 specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_LA(int)"><!-- --></A><H3>
QUE_M_LA</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_LA</B>(int&nbsp;Qid)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the <I>latest arrived</I> message as the candidate message from the
 specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_PREQ(int, int)"><!-- --></A><H3>
QUE_M_PREQ</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_PREQ</B>(int&nbsp;Qid,
                                            int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with priority <I>equal</I> to <I>n</I> as the
 candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer priority value. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_PRNE(int, int)"><!-- --></A><H3>
QUE_M_PRNE</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_PRNE</B>(int&nbsp;Qid,
                                            int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with priority <I>not equal</I> to <I>n</I> as the
 candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer priority value. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_PRGT(int, int)"><!-- --></A><H3>
QUE_M_PRGT</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_PRGT</B>(int&nbsp;Qid,
                                            int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with priority <I>greater than</I> <I>n</I> as the
 candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer priority value. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_PRGE(int, int)"><!-- --></A><H3>
QUE_M_PRGE</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_PRGE</B>(int&nbsp;Qid,
                                            int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with priority <I>greater</I> than or <I>equal</I> to
 <I>n</I> as the candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer priority value. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_PRLT(int, int)"><!-- --></A><H3>
QUE_M_PRLT</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_PRLT</B>(int&nbsp;Qid,
                                            int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with priority <I>less than</I> <I>n</I> as the
 candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer priority value. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_PRLE(int, int)"><!-- --></A><H3>
QUE_M_PRLE</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_PRLE</B>(int&nbsp;Qid,
                                            int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with priority <I>less</I> than or <I>equal</I> to
 <I>n</I> as the candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer priority value. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_PRRNG(int, int, int)"><!-- --></A><H3>
QUE_M_PRRNG</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_PRRNG</B>(int&nbsp;Qid,
                                             int&nbsp;n,
                                             int&nbsp;m)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with priority in the <I>range</I> <I>n</I> through
 <I>m</I> as the candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer priority value.<DD><CODE>m</CODE> - An integer priority value. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_SEQEQ(int, int)"><!-- --></A><H3>
QUE_M_SEQEQ</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_SEQEQ</B>(int&nbsp;Qid,
                                             int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with sequence number <I>equal</I> to <I>n</I> as the
 candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer sequence number. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_SEQGT(int, int)"><!-- --></A><H3>
QUE_M_SEQGT</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_SEQGT</B>(int&nbsp;Qid,
                                             int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with sequence number <I>greater</I> than <I>n</I> as
 the candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer sequence number. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_SEQGE(int, int)"><!-- --></A><H3>
QUE_M_SEQGE</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_SEQGE</B>(int&nbsp;Qid,
                                             int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with sequence number <I>greater</I> than or
 <I>equal</I> to <I>n</I> as the candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer sequence number. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_SEQLT(int, int)"><!-- --></A><H3>
QUE_M_SEQLT</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_SEQLT</B>(int&nbsp;Qid,
                                             int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with sequence number <I>less</I> than <I>n</I> as the
 candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer sequence number. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QUE_M_SEQLE(int, int)"><!-- --></A><H3>
QUE_M_SEQLE</H3>
<PRE>
public static final <A HREF="../javaxipc30/MsgSelectQid.html">MsgSelectQid</A> <B>QUE_M_SEQLE</B>(int&nbsp;Qid,
                                             int&nbsp;n)</PRE>
<DL>
<DD>A QueReceive Message Select Code.
 For QueReceive operations, used as an argument to QueListBuild or QueListAdd to
 select the first message with sequence number <I>less</I> than or <I>equal</I>
 to <I>n</I> as the candidate message from the specified queue.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Qid</CODE> - An integer queue id.<DD><CODE>n</CODE> - An integer sequence number. <p><dt><b>Examples:</b>
                   <dd>See section on <A HREF="XipcSelectCodes.html">Queue and
                   Message Select Codes</A> <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Xipc.html#QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)"><CODE>QueReceive(int, javaxipc30.QidList, byte[], int, javaxipc30.XintRef, javaxipc30.XintRef, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="QueRemove(javaxipc30.MsgHdr)"><!-- --></A><H3>
QueRemove</H3>
<PRE>
public final int <B>QueRemove</B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueSend(int, javaxipc30.QidList, byte[], int, int, javaxipc30.XintRef, int)"><!-- --></A><H3>
QueSend</H3>
<PRE>
public final int <B>QueSend</B>(int&nbsp;QueSelectCode,
                         <A HREF="../javaxipc30/QidList.html">QidList</A>&nbsp;QidList,
                         byte[]&nbsp;MsgBuf,
                         int&nbsp;MsgLength,
                         int&nbsp;Priority,
                         <A HREF="../javaxipc30/XintRef.html">XintRef</A>&nbsp;RetQid,
                         int&nbsp;BlockOpt)</PRE>
<DL>
<DD>Write and send a message to a queue.
 QueSend() attempts to write the message text in <I>MsgBuf</I> into the QueSys
 message text pool and then put a header referring to it onto one of the queues
 listed in <I>QidList</I>. The selection of a target queue is based on the value
 of <I>QueSelectCode</I>.
 See section on <A HREF="XipcSelectCodes.html">Queue and Message Select
 Codes</A> for more information on queue select codes.
 QueSend() first attempts to write the message's text to the QueSys message text
 pool, creating for it a message header. It then attempts to put the created
 message header onto one of the queues in <I>QidList</I> based on the value of
 <I>QueSelectCode</I>.
 <P>QueSend() is given the potential to block by setting <I>BlockOpt</I>
 appropriately. The operation will block if:
 <UL>
 <LI>The message text pool currently lacks the capacity for a message text of
 size <I>MsgLength</I>. </LI>
 <LI>All the queues listed in <I>QidList</I> are currently filled to their
 message or byte capacities. </LI>
 </UL>
 A QueSend() operation completes when the cause of it not completing is removed,
 usually by another user's actions. Specifically:
 <UL>
 <LI>Another user calling QueRead() to remove a message's text from the message
 text pool. </LI>
 <LI>Another user calling QueGet() to retrieve a message from one of the
 involved queues. </LI>
 <LI>Another user calling QueReceive() to accomplish both effects. </LI>
 </UL>
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>QueSelectCode</CODE> - A code indicating the selection criteria
                   to be used in determining the target queue of the QueSend()
                   operation. The selected queue is one of the Qids in
                   <I>QidList</I>. The possible values for <I>QueSelectCode</I>
                   are listed and explained in the section on <A
                   HREF="XipcSelectCodes.html">queue and message select
                   codes</A>.<DD><CODE>QidList</CODE> - A list of Qids for consideration as the target
                   queue of the QueSend() operation. A QidList is constructed
                   using QueList() or QueListBuild() and is updated using
                   QueListAdd().<DD><CODE>MsgBuf</CODE> - An array of bytes to serve as a message buffer
                   to receive the message text.<DD><CODE>MsgLength</CODE> - An integer specifying the maximum number of
                   bytes to be copied from the retrieved message into
                   <I>MsgBuf</I>. QUE_TRUNCATE(<I>MsgLength</I>) must be
                   specified if text truncation is desired for messages
                   exceeding bytes in size. <I>MsgLength</I> must be greater
                   than 0, and not greater than the length of <I>MsgBuf</I>.<DD><CODE>Priority</CODE> - A positive integer to be designated as the
                   message's priority.<DD><CODE>RetQid</CODE> - An XintRef object that gets assigned by
                   QueSend() upon its return. Successful QueSend() operations
                   (RC>=0) return with RetQid containing the Qid of the selected
                   target queue (from within QidList) that received the sent
                   message. Cancelled QueSend() operations having return code
                   equal XipcErr.QUE_ER_DESTROYED or XipcErr.QUE_ER_PURGED,
                   return with RetQid containing the destroyed or purged Qid.
                   Failed calls with return code equal XipcErr.QUE_ER_BADQID
                   return with RetQid containing the invalid Qid. The contents
                   of RetQid is otherwise undefined. <tt>null</tt> may be passed
                   if the value returned by this parameter is not required.<DD><CODE>BlockOpt</CODE> - One of QUE_WAIT, QUE_NOWAIT or QUE_TIMEOUT(t)
                   for an integer t. See <A
                   HREF="XipcBlockingOption.html">blocking option parameter</A>
                   for further information.<DT><B>Returns:</B><DD><dd>RC>=0 -  Send successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.QUE_ER_BADBLOCKOPT - Invalid <I>BlockOpt</I>.
                   <dd>XipcErr.QUE_ER_BADBUFFER - <I>MsgBuf</I> is NULL.
                   <dd>XipcErr.QUE_ER_BADLENGTH - Invalid <I>MsgLength</I>
                   parameter.
                   <dd>XipcErr.QUE_ER_BADOPTION - Invalid <I>BlockOpt</I>
                   parameter.
                   <dd>XipcErr.QUE_ER_BADPRIORITY - Invalid <I>Priority</I>
                   parameter.
                   <dd>XipcErr.QUE_ER_BADQID - Bad Qid in QidList (it's value is
                   in <I>RetSid</I>).
                   <dd>XipcErr.QUE_ER_BADQIDLIST - Invalid QidList parameter.
                   <dd>XipcErr.QUE_ER_BADQUESELECTCODE - Invalid QueSelectCode
                   parameter.
                   <dd>XipcErr.QUE_ER_CAPACITY - QueSys internal system capacity
                   error.
                   <dd>XipcErr.QUE_ER_DESTROYED - Another user destroyed a queue
                   that the blocked QueSend() call was waiting on. The blocked
                   QueSend() operation was cancelled. No message was sent.
                   <dd>XipcErr.QUE_ER_NOSUBSYSTEM - QueSys is not configured in
                   the instance.
                   <dd>XipcErr.QUE_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.QUE_ER_NOWAIT - <I>BlockOpt</I> of QUE_NOWAIT was
                   specified and request was not immediately satisfied.
                   <dd>XipcErr.QUE_ER_PURGED - Another user purged a queue that
                   the blocked QueSend() call was waiting on. The blocked
                   QueSend() operation was cancelled. No message was sent.
                   <dd>XipcErr.QUE_ER_TIMEOUT - The blocked QueSend() operation
                   timed out.
                   <dd>XipcErr.QUE_ER_TOOBIG - The size of the message exceeds
                   the byte capacity of one of the listed Qids (the Qid is in
                   <I>RetSid</I>).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <dd>XipcErr.XIPCNET_ER_TOOBIG - Message text exceeds
                   instance's size limit.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc cnnct = new Xipc();
                   int uid = cnnct.XipcLogin("@server:NetInstance", "user");
                   int qid1 = cnnct.QueAccess("queue1");
                   int qid2 = cnnct.QueAccess("queue2");
                   int qid3 = cnnct.QueAccess("queue3");
                   QidList ql = Xipc.QueListBuild(qid1);
                   Xipc.QueListAdd(ql, qid2);
                   Xipc.QueListAdd(ql, qid3);
                   XintRef retQid = new XintRef(-1);
                   String msg = "this is the message";
                   byte[] buf = msg.getBytes();	 // converts String to byte
                   array
                   int rc = cnnct.QueSend(Xipc.QUE_Q_SHQ, ql, buf, buf.length,
                   99, retQid, Xipc.QUE_WAIT);
                   System.out.println("msg went to queue with qid = " +
                   retQid.getValue());
                   </pre>
                   An Xipc object is created, and a login is performed.
                   Three queues are accessed, and a QidList is created
                   containing their queue id's.
                   A message string is converted to a byte array.
                   Then the message is sent to the shortest of the three queues,
                   and that queues queue id is printed.</DL>
</DD>
</DL>
<HR>

<A NAME="QueSpool(int, java.lang.String)"><!-- --></A><H3>
QueSpool</H3>
<PRE>
public final int <B>QueSpool</B>(int&nbsp;Qid,
                          java.lang.String&nbsp;spoolFileName)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueTrigger(int, javaxipc30.QueTriggerSpec)"><!-- --></A><H3>
QueTrigger</H3>
<PRE>
public final int <B>QueTrigger</B>(int&nbsp;Sid,
                            <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A>&nbsp;trigSpec)</PRE>
<DL>
<DD>Define a QueSys Trigger.
 A QueSys trigger is a logical link between a QueSys event and a SemSys event
 semaphore. The semaphore is automatically set when the QueSys event occurs.
 A trigger is defined by:
 <ul>
 <li> The Id of an event semaphore that will be set when the QueSys event
 occurs.</li>
 <li> A QueSys event specification.</li>
 </ul>
 The Sid of the event semaphore is obtained by calling SemSys functions
 SemCreate() or SemAccess().
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Sid</CODE> - The Semaphore ID of the event semaphore to be set
                   when the trigger event occurs.  The Sid is obtained
                   by SemCreate() or SemAccess() function calls.<DD><CODE>trigSpec</CODE> - Specification of the QueSys trigger event.
                   The event is specified by a call to an Xipc QueTrigger method (the method name
                   beginning with QUE_T_)<DT><B>Returns:</B><DD><dd>RC>=0 - QueTrigger successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.QUE_ER_BADQID - Qid is not a valid queue ID.
                   <dd>XipcErr.QUE_ER_BADSID - Sid is not a valid semaphore ID.
                   <dd>XipcErr.QUE_ER_BADTRIGGERCODE - Bad trigger code.
                   <dd>XipcErr.QUE_ER_BADUID - Uid is not a valid user id.
                   <dd>XipcErr.QUE_ER_BADVAL - Illegal trigger parameter value.
                   <dd>XipcErr.QUE_ER_CAPACITY_NODE - QueSys node table full.
                   <dd>XipcErr.QUE_ER_DUPLICATE - Attempt to define a trigger that is already defined
                   <dd>XipcErr.QUE_ER_NOSUBSYSTEM - QueSys is not configured in the instance.
                   <dd>XipcErr.QUE_ER_NOTLOGGEDIN - User not logged into instance (User never logged in, was
                   aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <dd>XipcErr.XIPCNET_ER_SYSERR - Operating system error.
                   <p></DL>
</DD>
</DL>
<HR>

<A NAME="QueUntrigger(int, javaxipc30.QueTriggerSpec)"><!-- --></A><H3>
QueUntrigger</H3>
<PRE>
public final int <B>QueUntrigger</B>(int&nbsp;Sid,
                              <A HREF="../javaxipc30/QueTriggerSpec.html">QueTriggerSpec</A>&nbsp;trigSpec)</PRE>
<DL>
<DD>Undefine a QueSys Trigger.
 QueUntrigger() is used to undefine a trigger that was previously defined using the QueTrigger()
 function.
 The parameters to QueUntrigger() must be the same as were used to originally define the trigger.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Sid</CODE> - The Semaphore Id of the event semaphore associated with the trigger to be
                   undefined.<DD><CODE>trigSpec</CODE> - TriggerSpec Specification of the QueSys trigger to be undefined.<DT><B>Returns:</B><DD><dd>RC>=0 - QueTrigger successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.QUE_ER_BADQID - Qid is not a valid queue ID.
                   <dd>XipcErr.QUE_ER_BADSID - Sid is not a valid semaphore ID.
                   <dd>XipcErr.QUE_ER_BADTRIGGERCODE - Bad trigger code.
                   <dd>XipcErr.QUE_ER_BADUID - Uid is not a valid user id.
                   <dd>XipcErr.QUE_ER_BADVAL - Illegal trigger parameter value.
                   <dd>XipcErr.QUE_ER_NOSUBSYSTEM - QueSys is not configured in the instance.
                   <dd>XipcErr.QUE_ER_NOTLOGGEDIN - User not logged into instance (User never logged in, was
                   aborted or disconnected).
                   <dd>XipcErr.QUE_ER_TRIGGERNOTEXIST - Trigger not previously defined.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <dd>XipcErr.XIPCNET_ER_SYSERR - Operating system error.
                   <p></DL>
</DD>
</DL>
<HR>

<A NAME="QueUnfreeze()"><!-- --></A><H3>
QueUnfreeze</H3>
<PRE>
public final int <B>QueUnfreeze</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="QueUnget(javaxipc30.MsgHdr)"><!-- --></A><H3>
QueUnget</H3>
<PRE>
public final int <B>QueUnget</B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr)</PRE>
<DL>
</DL>
<HR>

<A NAME="QueWrite(javaxipc30.MsgHdr, byte[], int, int)"><!-- --></A><H3>
QueWrite</H3>
<PRE>
public final int <B>QueWrite</B>(<A HREF="../javaxipc30/MsgHdr.html">MsgHdr</A>&nbsp;msgHdr,
                          byte[]&nbsp;MsgBuf,
                          int&nbsp;MsgLength,
                          int&nbsp;BlockOpt)</PRE>
<DL>
</DL>
<HR>

<A NAME="MemAccess(java.lang.String)"><!-- --></A><H3>
MemAccess</H3>
<PRE>
public final int <B>MemAccess</B>(java.lang.String&nbsp;Name)</PRE>
<DL>
<DD>Access an existing memory segment.
 MemAccess() accesses an existing memory segment in MemSys. <I>Name</I>
 is used for identifying the desired memory segment. The method returns the Mid
 of the accessed memory segment.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Name</CODE> - A String object that contains the symbolic name
                   identifying the desired memory segment. <I>Name</I> must not
                   exceed MEM_LEN_XIPCNAME characters, must identify an existing
                   memory segment and cannot be MEM_PRIVATE.<DT><B>Returns:</B><DD><dd>RC>=0 - Access successful. RC is the memory segment ID
                   (Mid). Mid is to be used in all subsequent MemSys operations
                   that refer to this memory segment.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADSEGNAME - Invalid <I>Name</I>
                   parameter.
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in
                   the instance.
                   <dd>XipcErr.MEM_ER_NOTFOUND - Memory segment with <I>Name</I>
                   does not exist.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid1 = connection.MemCreate("segment1", 1024);
                   if (mid1 == XipcErr.MEM_ER_DUPLICATE) mid1 =
                   connection.MemAccess("segment1");
                   </pre>
                   After logging in to an instance through an Xipc object, an
                   attempt is made to create a shared memory segment with the
                   name "segment1".
                   If the return code indicates that a segment with that name
                   already exists, then MemAccess is used to get it's memory
                   segment id (mid).</DL>
</DD>
</DL>
<HR>

<A NAME="MemCreate(java.lang.String, int)"><!-- --></A><H3>
MemCreate</H3>
<PRE>
public final int <B>MemCreate</B>(java.lang.String&nbsp;Name,
                           int&nbsp;Size)</PRE>
<DL>
<DD>Create a New Memory Segment.
 MemCreate() creates a new memory segment in MemSys. <I>Name</I> is used for
 publicly identifying the new memory segment. A <I>Name</I> of MEM_PRIVATE
 directs MemSys to create a private memory segment (i.e. having no public
 identification). The segment is created having a size of <I>Size</I> bytes.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Name</CODE> - A String that contains a symbolic name for
                   publicly identifying the memory segment. <I>Name</I> must not
                   exceed MEM_LEN_XIPCNAME characters. If <I>Name</I> is
                   MEM_PRIVATE then a private memory segment is created.
                   Duplicate memory segment names (other than MEM_PRIVATE) are
                   illegal.<DD><CODE>Size</CODE> - The size of the memory segment to be created. The
                   size is specified in units of bytes. <I>Size</I> must be
                   greater than zero.<DT><B>Returns:</B><DD><dd>RC>=0 - Create successful. RC is memory segment ID (Mid).
                   Mid is to be used in all subsequent MemSys calls that refer
                   to this memory segment.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADSEGNAME - Invalid <I>Name</I>
                   parameter.
                   <dd>XipcErr.MEM_ER_BADSIZE - Invalid <I>Size</I> parameter.
                   <dd>XipcErr.MEM_ER_CAPACITY - Internal capacity exceeded.
                   <dd>XipcErr.MEM_ER_DUPLICATE - Memory Segment with
                   <I>Name</I> already exists.
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in
                   the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid = connection.MemCreate("segment1", 1024);
                   </pre>
                   A login is performed, and a shared memory segment is created
                   with name "segment1"
                   and a size of 1024 bytes.  The memory segments id (mid) is
                   placed in <tt>mid</tt>.</DL>
</DD>
</DL>
<HR>

<A NAME="MemDelete(int)"><!-- --></A><H3>
MemDelete</H3>
<PRE>
public final int <B>MemDelete</B>(int&nbsp;Mid)</PRE>
<DL>
<DD>Delete a Memory Segment.
 MemDelete() deletes the MemSys segment identified by <I>Mid</I> from MemSys.
 MemDelete() will fail if any sections are defined over the segment or if any
 user is blocked trying to lock, own, write or read the segment.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Mid</CODE> - The memory segment ID of the MemSys segment to be
                   deleted. <I>Mid</I> was obtained by the user via MemCreate()
                   or MemAccess() method calls.<DT><B>Returns:</B><DD><dd>RC>=0 - Delete successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADMID - Invalid Memory Segment ID
                   <I>Mid</I>.
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in
                   the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.MEM_ER_MEMBUSY - MemSys Segment has one or more
                   sections defined over it.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid1 = connection.MemAccess("segment1");
                   int retcode = connection.MemDelete(mid1);
                   </pre>
                   After logging in, an existing shared memory segment is
                   accessed, and MemDelete is used to delete it from the system.</DL>
</DD>
</DL>
<HR>

<A NAME="MemDestroy(int)"><!-- --></A><H3>
MemDestroy</H3>
<PRE>
public final int <B>MemDestroy</B>(int&nbsp;Mid)</PRE>
<DL>
<DD>Destroy a MemSys Memory Segment.
 MemDestroy() deletes the MemSys segment identified by <I>Mid</I> from MemSys.
 MemDestroy() deletes the segment even if sections are currently defined over it
 or users are waiting to lock, own, write or read the segment.
 <P>Blocked MemSys operations (i.e. MemRead(), MemWrite(), MemLock()or
 MemSecOwn()), initiated by other users involving memory segment <I>Mid</I>, are
 interrupted and returned with return code equal to XipcErr.MEM_ER_DESTROYED,
 indicating the forced deletion of memory segment <I>Mid</I>.
 <P>Users currently locking or owning section(s) defined over the destroyed
 memory segment have those sections silently removed from their possession.
 These users are not explicitly notified of the segment's forced deletion.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Mid</CODE> - The memory segment ID of the MemSys segment to be
                   destroyed. <I>Mid</I> was obtained by the user via
                   MemCreate() or MemAccess() method calls.<DT><B>Returns:</B><DD><dd>RC>=0 - Destroy successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADMID - Invalid Memory Segment ID
                   <I>Mid</I>.
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in
                   the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <dd>XipcErr.XIPCNET_ER_TOOBIG - Text exceed instance's size
                   limit.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid1 = connection.MemAccess("segment1");
                   int retcode = connection.MemDestroy(mid1);
                   </pre>
                   After logging in, an existing shared memory segment is
                   accessed, and then it is destroyed with MemDestroy.</DL>
</DD>
</DL>
<HR>

<A NAME="MemFreeze()"><!-- --></A><H3>
MemFreeze</H3>
<PRE>
public final int <B>MemFreeze</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="MemInfoMem(int, javaxipc30.MemInfoMem)"><!-- --></A><H3>
MemInfoMem</H3>
<PRE>
public final int <B>MemInfoMem</B>(int&nbsp;mid,
                            <A HREF="../javaxipc30/MemInfoMem.html">MemInfoMem</A>&nbsp;infoMem)</PRE>
<DL>
</DL>
<HR>

<A NAME="MemInfoSec(javaxipc30.Section, javaxipc30.MemInfoSec)"><!-- --></A><H3>
MemInfoSec</H3>
<PRE>
public final int <B>MemInfoSec</B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;section,
                            <A HREF="../javaxipc30/MemInfoSec.html">MemInfoSec</A>&nbsp;infoSec)</PRE>
<DL>
</DL>
<HR>

<A NAME="MemInfoSys(javaxipc30.MemInfoSys)"><!-- --></A><H3>
MemInfoSys</H3>
<PRE>
public final int <B>MemInfoSys</B>(<A HREF="../javaxipc30/MemInfoSys.html">MemInfoSys</A>&nbsp;InfoSys)</PRE>
<DL>
</DL>
<HR>

<A NAME="MemInfoUser(int, javaxipc30.MemInfoUser)"><!-- --></A><H3>
MemInfoUser</H3>
<PRE>
public final int <B>MemInfoUser</B>(int&nbsp;Uid,
                             <A HREF="../javaxipc30/MemInfoUser.html">MemInfoUser</A>&nbsp;InfoUser)</PRE>
<DL>
</DL>
<HR>

<A NAME="MemUnfreeze()"><!-- --></A><H3>
MemUnfreeze</H3>
<PRE>
public final int <B>MemUnfreeze</B>()</PRE>
<DL>
</DL>
<HR>

<A NAME="MemListBuild(javaxipc30.Section)"><!-- --></A><H3>
MemListBuild</H3>
<PRE>
public static final <A HREF="../javaxipc30/MidList.html">MidList</A> <B>MemListBuild</B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;Section)</PRE>
<DL>
<DD>Build a reusable list of memory sections.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Section</CODE> - A Section object to included in the MidList.<DT><B>Returns:</B><DD><dd>RC!=<TT>null</TT> - A new MidList containing the given
                   Section.
                   <dd>RC=<TT>null</TT> - <I>MidList</I> exceeded
                   MEM_LEN_MIDLIST elements.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid1 = connection.MemAccess("segment1");
                   MidList ml =
                   Xipc.MemListBuild(Xipc.MemSectionBuild(mid1,100,20));
                   </pre>
                   After logging in, an existing shared memory segment is
                   accessed and a MidList is built containing a section of that
                   segment beginning at offset 100 and ending at offset 119
                   (size=20).
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/MidList.html"><CODE>MidList</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MemListAdd(javaxipc30.MidList, javaxipc30.Section)"><!-- --></A><H3>
MemListAdd</H3>
<PRE>
public static final <A HREF="../javaxipc30/MidList.html">MidList</A> <B>MemListAdd</B>(<A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;ml,
                                       <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;Section)</PRE>
<DL>
<DD>Add to a list of memory sections.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ml</CODE> - A MidList object that is to be updated.<DD><CODE>Section</CODE> - A Section object.<DT><B>Returns:</B><DD><dd>RC!=<TT>null</TT> - The Midlist ml, updated to include
                   the given Section.
                   <dd>RC=<TT>null</TT> - <I>MidList</I> exceeded
                   MEM_LEN_MIDLIST elements.
                   <p>
                   <A NAME="MemListBuild Example"><dt><b>Example:</b></A>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid1 = connection.MemAccess("segment1");
                   int mid2 = connection.MemAccess("segment2");
                   int mid3 = connection.MemAccess("segment3");
                   MidList ml =
                   Xipc.MemListBuild(Xipc.MemSectionBuild(mid1,0,50));
                   Xipc.MemListAdd(ml, Xipc.MemSectionBuild(mid2,0,50));
                   Xipc.MemListAdd(ml, Xipc.MemSectionBuild(mid3,0,50));
                   </pre>
                   After logging in, three existing shared memory segments are
                   accessed.	A MidList is created containing the sections of
                   each of these segments, each section consisting of the first
                   50 bytes of its segment.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/MidList.html"><CODE>MidList</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="MemLock(int, javaxipc30.MidList, javaxipc30.Section, int)"><!-- --></A><H3>
MemLock</H3>
<PRE>
public final int <B>MemLock</B>(int&nbsp;LockType,
                         <A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;MidList,
                         <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;retSec,
                         int&nbsp;BlockOpt)</PRE>
<DL>
<DD>Lock Memory Section(s).
 <P>MemLock() attempts to lock the memory sections in <I>MidList</I> for the
 calling user's exclusive read-write access, based on the values of
 <I>LockType</I> and <I>BlockOpt</I>. The value of <I>LockType</I> specifies how
 to satisfy the requested lock:
 <UL>
 <LI>If <I>LockType</I> = MEM_ANY, the request is considered satisfied when any
 one of the memory sections in <I>MidList</I> has been locked.
 </LI>
 <LI>If <I>LockType</I> = MEM_ALL, the request is not considered satisfied until
 all the memory sections in <I>MidList</I> have been locked. Memory sections are
 locked as they become available until all the sections in <I>MidList</I> have
 been locked. </LI>
 <LI>If <I>LockType</I> = MEM_ATOMIC, the request is not considered satisfied
 until all the memory sections in <I>MidList</I> are available and then locked
 in a single atomic operation. Individual memory sections in <I>MidList</I>
 are not locked as they become available. In this way it differs from
 <I>LockType</I>
 = MEM_ALL.</LI>
 </UL>
 <P>MemLock() will not succeed in locking a section unless all of the segment
 bytes overlaid by the section are read and write accessible by the calling
 user.
 <P>The value of <I>BlockOpt</I> specifies whether the requested lock operation
 should block. See <A HREF="XipcBlockingOption.html">blocking option
 parameter</A>
 for further information.
 Satisfied MemLock() calls return the identity of the last locked memory section
 in <I>Sect</I>.
 <P>Calling MemLock() is the most direct approach for acquiring exclusive
 read-write control over one or more memory sections. MemLock() first defines
 the <I>MidList</I> list of memory sections that do not yet exist. It then
 acquires ownership rights over the sections as specified by <I>LockType</I>.
 It then sets their read-write privilege to read-write by the caller and
 non-accessible by others.
 In this way MemLock() is a concatenation of MemSecDef(), MemSecOwn() and
 MemSecPriv().
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>LockType</CODE> - MEM_ANY, MEM_ALL or MEM_ATOMIC depending on
                   the locking criteria desired.<DD><CODE>MidList</CODE> - A list of memory section(s) to be locked. This
                   list can be a MidList built by MemListBuild() and updated by
                   MemListAdd().<DD><CODE>retSec</CODE> - A Section object that gets updated by MemLock()
                   upon its return. Successful lock operations (RC &gt;= 0)
                   return with <I>Sect</I> identifying the last locked section.
                   Interrupted lock operations, where return code equals
                   XipcErr.MEM_ER_DESTROYED, return with <I>Sect</I> identifying
                   the destroyed section. Failed calls with return code equal to
                   XipcErr.MEM_ER_BADSECTION return with <I>Sect</I> identifying
                   the invalid section. <I>Sect</I> otherwise has undefined
                   contents. <tt>null</tt> may be passed if the value returned
                   by this parameter is not required.<DD><CODE>BlockOpt</CODE> - One of MEM_WAIT, MEM_NOWAIT or MEM_TIMEOUT(t)
                   for an integer t. See <A
                   HREF="XipcBlockingOption.html">blocking option parameter</A>
                   for further information.<DT><B>Returns:</B><DD><dd>RC>=0 - MemLock successful. If <I>LockType</I> = MEM_ANY
                   then one of the requested memory sections has been locked and
                   <I>Sect</I> identifies the locked memory section. If
                   <I>LockType</I>&nbsp;=&nbsp;MEM_ALL or MEM_ATOMIC then all
                   requested memory sections have been locked by the calling
                   user and <I>Sect</I> identifies the last memory section that
                   was locked.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADBLOCKOPT - Invalid <I>BlockOpt</I>.
                   <dd>XipcErr.MEM_ER_BADOPTION - Invalid <I>Options</I>
                   parameter.
                   <dd>XipcErr.MEM_ER_BADLOCKTYPE - Invalid <I>LockType</I>
                   parameter.
                   <dd>XipcErr.MEM_ER_BADSECTION - <I>MidList</I> contains a bad
                   section. <I>Sect</I>
                   is set to the invalid section.
                   <dd>XipcErr.MEM_ER_CAPACITY - Internal capacity exceeded.
                   <dd>XipcErr.MEM_ER_DESTROYED - Another user destroyed a
                   memory section that was being waited on by this user. The
                   blocked lock operation was cancelled. No memory sections were
                   locked. <I>Sect</I> identifies the destroyed memory section.
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in
                   the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.MEM_ER_NOWAIT - <I>BlockOpt</I> of MEM_NOWAIT was
                   specified and the request was not immediately satisfied.
                   <dd>XipcErr.MEM_ER_TIMEOUT - The time out period for the
                   blocked lock operation has expired without satisfying the
                   request.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid1 = connection.MemAccess("segment1");
                   MidList ml =
                   Xipc.MemListBuild(Xipc.MemSectionBuild(mid1,0,10));
                   Xipc.MemListAdd(ml, Xipc.MemSectionBuild(mid1,10,10));
                   Xipc.MemListAdd(ml, Xipc.MemSectionBuild(mid1,20,10));
                   Section lockedSect = new Section(-1, -1, -1);
                   int retcode = connection.MemLock(Xipc.MEM_ANY, ml,
                   lockedSect, Xipc.MEM_WAIT);
                   if (retcode>=0)
                   {
                   int offset = lockedSect.getOffset();
                   System.out.println("Locked 10 bytes of segment1 beginning at
                   " + offset);
                   }
                   </pre>
                   After logging in, the shared memory segment named "segment1"
                   is accessed.
                   A MidList is created containing sections overlaying the
                   first, second and third 10 byte sections of the segment. A
                   section object is created (using the Section constructor,
                   which is an alternative to MemSectionBuild) to pass to
                   MemLock, so that it can return which section was locked.
                   MemLock is used to lock any one of these sections, and the
                   offset of the locked section is printed.</DL>
</DD>
</DL>
<HR>

<A NAME="MemRead(int, int, int, byte[], int)"><!-- --></A><H3>
MemRead</H3>
<PRE>
public final int <B>MemRead</B>(int&nbsp;Mid,
                         int&nbsp;Offset,
                         int&nbsp;Length,
                         byte[]&nbsp;Buffer,
                         int&nbsp;BlockOpt)</PRE>
<DL>
<DD>Read data from a memory segment.
 MemRead() attempts to read <I>Length</I> bytes of data from the MemSys Segment
 identified by <I>Mid</I>, starting at <I>Offset</I> bytes from the start of the
 segment, into <I>Buffer</I>.
 <P>The MemRead() operation will succeed if and only if all the bytes targeted
 by the operation are currently readable by the calling user.
 <P>MemRead() operations are guaranteed to be atomic.
 <P>If the entire target area is protected from other user access (i.e.
 all overlaying sections are locked by the reading user),then the read operation
 is executed in its most efficient form,without the need for explicit protection
 by MemSys.
 <P>If however, any part of the target area is not protected from other user
 access (i.e. one or more of the overlaying sections are not locked by the
 calling user), then the atomic nature of the read operation is explicitly
 enforced by MemSys.
 <P>MemRead() is given the potential to block by setting <I>BlockOpt</I>
 appropriately. The operation will block if any bytes of the target area are not
 readable by the calling user. A MemRead() operation completes when the complete
 target memory area becomes readable by the caller. This is usually accomplished
 by another user's calling MemUnlock() <!-- or MemSecPriv() -->
 regarding the unreadable section(s) overlaying the target area.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Mid</CODE> - The memory segment ID of the segment to be read.
                   <I>Mid</I> was obtained by the user via MemCreate() or
                   MemAccess() method calls.<DD><CODE>Offset</CODE> - The number of bytes beyond the start of the
                   segment from where the MemRead operation should commence.<DD><CODE>Length</CODE> - The number of bytes to be read from the memory
                   segment into <I>Buffer</I>. Its value must be greater than 0.<DD><CODE>Buffer</CODE> - A pointer to the target data buffer.<DD><CODE>BlockOpt</CODE> - One of MEM_WAIT, MEM_NOWAIT or MEM_TIMEOUT(t)
                   for an integer t. See <A
                   HREF="XipcBlockingOption.html">blocking option parameter</A>
                   for further information.<DT><B>Returns:</B><DD><dd>RC>=0 - MemRead successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADBLOCKOPT - Invalid <I>BlockOpt</I>.
                   <dd>XipcErr.MEM_ER_BADBUFFER - <I>Buffer</I> is NULL.
                   <dd>XipcErr.MEM_ER_BADMID - Invalid Memory Segment ID
                   <I>Mid</I>.
                   <dd>XipcErr.MEM_ER_BADOPTION - Invalid <I>Options</I>
                   parameter.
                   <dd>XipcErr.MEM_ER_BADTARGET - Invalid target specification.
                   <dd>XipcErr.MEM_ER_CAPACITY - MemSys internal system capacity
                   error.
                   <dd>XipcErr.MEM_ER_DESTROYED - Another user destroyed the
                   memory segment targeted by the blocked MemRead operation.
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in
                   the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.MEM_ER_NOWAIT - <I>BlockOpt</I> of MEM_NOWAIT
                   specified and request was not immediately satisfied.
                   <dd>XipcErr.MEM_ER_TIMEOUT - The blocked MemRead() operation
                   timed out.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p>
                   <A NAME="MemRead Example"><dt><b>Example:</b></A>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid1 = connection.MemAccess("segment1");
                   MidList ml =
                   Xipc.MemListBuild(Xipc.MemSectionBuild(mid1,0,10));
                   Xipc.MemListAdd(ml, Xipc.MemSectionBuild(mid1,10,10));
                   Xipc.MemListAdd(ml, Xipc.MemSectionBuild(mid1,20,10));
                   Section lockedSect = new Section(-1, -1, -1);
                   byte[] buf = new byte[10];
                   int retcode = connection.MemLock(Xipc.MEM_ANY, ml,
                   lockedSect, Xipc.MEM_WAIT);
                   if (retcode>=0)
                   {
                   int offset = lockedSect.getOffset();
                   connection.MemRead(mid1, offset, 10, buf, Xipc.MEM_WAIT);
                   modify(buf);
                   connection.MemWrite(mid1, offset, 10, buf, Xipc.MEM_WAIT);
                   connection.MemUnlock(Xipc.MemListBuild(lockedSect),null);
                   }
                   </pre>
                   After logging in, the shared memory segment named "segment1"
                   is accessed.
                   A MidList is created containing sections overlaying the
                   first, second and third 10 byte sections of the segment. A
                   section object is created (using the Section constructor,
                   which is an alternative to MemSectionBuild) to pass to
                   MemLock, so that it can return which section was locked.
                   MemLock is used to lock any one of these sections.
                   MemRead is used to read its contents into the byte array
                   <tt>buf</tt>. The buffer is modified by the users
                   <tt>modify</tt> method, and written back to the section using
                   MemWrite.
                   The locked section is then unlocked.</DL>
</DD>
</DL>
<HR>

<A NAME="MemSecDef(javaxipc30.Section)"><!-- --></A><H3>
MemSecDef</H3>
<PRE>
public final int <B>MemSecDef</B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;section)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>section</CODE> - autofilled</DL>
</DD>
</DL>
<HR>

<A NAME="MemSecOwn(int, javaxipc30.MidList, javaxipc30.Section, int)"><!-- --></A><H3>
MemSecOwn</H3>
<PRE>
public final int <B>MemSecOwn</B>(int&nbsp;ownType,
                           <A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;midList,
                           <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;retSec,
                           int&nbsp;blockOpt)</PRE>
<DL>
</DL>
<HR>

<A NAME="MemSecPriv(javaxipc30.Section, int, int)"><!-- --></A><H3>
MemSecPriv</H3>
<PRE>
public final int <B>MemSecPriv</B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;section,
                            int&nbsp;ownerPrivilege,
                            int&nbsp;otherPrivilege)</PRE>
<DL>
</DL>
<HR>

<A NAME="MemSecRel(javaxipc30.MidList, javaxipc30.Section)"><!-- --></A><H3>
MemSecRel</H3>
<PRE>
public final int <B>MemSecRel</B>(<A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;midList,
                           <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;retSec)</PRE>
<DL>
</DL>
<HR>

<A NAME="MemSecUndef(javaxipc30.Section)"><!-- --></A><H3>
MemSecUndef</H3>
<PRE>
public final int <B>MemSecUndef</B>(<A HREF="../javaxipc30/Section.html">Section</A>&nbsp;section)</PRE>
<DL>
</DL>
<HR>

<A NAME="MemTrigger(int, javaxipc30.MemTriggerSpec)"><!-- --></A><H3>
MemTrigger</H3>
<PRE>
public final int <B>MemTrigger</B>(int&nbsp;Sid,
                            <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A>&nbsp;trigSpec)</PRE>
<DL>
<DD>Define a MemSys Trigger.
 A MemSys trigger is a logical link between a MemSys event and a SemSys event
 semaphore. The semaphore is automatically set when the MemSys event occurs.
 A trigger is defined by:
 <ul>
 <li> The Id of an event semaphore that will be set when the MemSys event
 occurs.</li>
 <li> A MemSys event specification.</li>
 </ul>
 The Sid of the event semaphore is obtained by calling SemSys functions
 SemCreate() or SemAccess().
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Sid</CODE> - The Semaphore ID of the event semaphore to be set
                   when the trigger event occurs.  The Sid is obtained
                   by SemCreate() or SemAccess() function calls.<DD><CODE>trigSpec</CODE> - Specification of the MemSys trigger event.
                   The event is specified by a call to an Xipc MemTrigger method (the method name
                   beginning with MEM_T_)<DT><B>Returns:</B><DD><dd>RC>=0 - MemTrigger successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADMID - Mid is not a valid segment ID.
                   <dd>XipcErr.MEM_ER_BADSID - Sid is not a valid semaphore ID.
                   <dd>XipcErr.MEM_ER_BADTRIGGERCODE - Bad trigger code
                   <dd>XipcErr.MEM_ER_BADUID - Uid is not a valid user ID.
                   <dd>XipcErr.MEM_ER_BADVAL - Illegal trigger parameter value
                   <dd>XipcErr.MEM_ER_BADTARGET - Illegal shared memory offset
                   <dd>XipcErr.MEM_ER_CAPACITY_NODE - MemSys node table full.
                   <dd>XipcErr.MEM_ER_DUPLICATE - Attempt to define a trigger that is already defined
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into instance (User never logged in, was
                   aborted or disconnected).
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <dd>XipcErr.XIPCNET_ER_SYSERR - Operating system error.
                   <p></DL>
</DD>
</DL>
<HR>

<A NAME="MemUntrigger(int, javaxipc30.MemTriggerSpec)"><!-- --></A><H3>
MemUntrigger</H3>
<PRE>
public final int <B>MemUntrigger</B>(int&nbsp;Sid,
                              <A HREF="../javaxipc30/MemTriggerSpec.html">MemTriggerSpec</A>&nbsp;trigSpec)</PRE>
<DL>
<DD>Undefine a MemSys Trigger.
 MemUntrigger() is used to undefine a trigger that was previously defined using the MemTrigger()
 function.
 The parameters to MemUntrigger() must be the same as were used to originally define the trigger.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Sid</CODE> - The Semaphore Id of the event semaphore associated with the trigger to be
                   undefined.<DD><CODE>trigSpec</CODE> - TriggerSpec Specification of the MemSys trigger to be undefined.<DT><B>Returns:</B><DD><dd>RC>=0 - MemTrigger successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADMID - Mid is not a valid segment ID.
                   <dd>XipcErr.MEM_ER_BADSID - Sid is not a valid semaphore ID.
                   <dd>XipcErr.MEM_ER_BADTRIGGERCODE - Bad trigger code
                   <dd>XipcErr.MEM_ER_BADUID - Uid is not a valid user ID.
                   <dd>XipcErr.MEM_ER_BADVAL - Illegal trigger parameter value
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into instance (User never logged in, was
                   aborted or disconnected).
                   <dd>XipcErr. MEM_ER_TRIGGERNOTEXIST - Trigger not previously defined
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <dd>XipcErr.XIPCNET_ER_SYSERR - Operating system error.
                   <p></DL>
</DD>
</DL>
<HR>

<A NAME="MemUnlock(javaxipc30.MidList, javaxipc30.Section)"><!-- --></A><H3>
MemUnlock</H3>
<PRE>
public final int <B>MemUnlock</B>(<A HREF="../javaxipc30/MidList.html">MidList</A>&nbsp;MidList,
                           <A HREF="../javaxipc30/Section.html">Section</A>&nbsp;retSec)</PRE>
<DL>
<DD>Unlock memory section(s).
 MemUnlock() unlocks the memory section(s) specified in the<I> MidList</I>.
 MemUnlock() will fail if any of the listed sections are not currently locked by
 the user (return code equals XipcErr.MEM_ER_NOTLOCKED).
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>MidList</CODE> - A list of sections being unlocked. This list
                   can be a MidList built by MemList() or MemListBuild().<DD><CODE>retSec</CODE> - A Section object that gets assigned a value by
                   MemUnlock() on return. For failed calls, where return code
                   equals XipcErr.MEM_ER_BADSECTION or return code equals
                   XipcErr.MEM_ER_NOTLOCKED, <I>Sect</I> identifies the invalid
                   section. For successful calls <I>Sect</I> identifies the last
                   memory section unlocked. <I>Sect</I> is otherwise undefined.
                   <tt>null</tt> may be passed if the value returned by this
                   parameter is not required.<DT><B>Returns:</B><DD><dd>RC>=0 - MemUnlock successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADSECTION - <I>MidList</I> contains a bad
                   section. <I>Sect</I>
                   identifies the invalid section.
                   <dd>XipcErr.MEM_ER_BADMIDLIST - Invalid MidList parameter.
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in
                   the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.MEM_ER_NOTLOCKED - <I>MidList</I> contains a
                   memory section not currently locked by the user. <I>Sect</I>
                   identifies the invalid section.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd>See MemRead <A HREF="#MemRead Example">example</A> for an
                   example of usage of MemUnlock</A>.</DL>
</DD>
</DL>
<HR>

<A NAME="MemWrite(int, int, int, byte[], int)"><!-- --></A><H3>
MemWrite</H3>
<PRE>
public final int <B>MemWrite</B>(int&nbsp;Mid,
                          int&nbsp;Offset,
                          int&nbsp;Length,
                          byte[]&nbsp;Buffer,
                          int&nbsp;BlockOpt)</PRE>
<DL>
<DD>Write data from a buffer into a memory segment.
 MemWrite() attempts to write <I>Length</I> bytes of data from <I>Buffer</I>
 into the memory segment identified by <I>Mid</I>, starting at <I>Offset</I>
 bytes from the start of the segment.
 <P>The MemWrite operation will succeed if and only if all the bytes targeted by
 the operation are currently writeable by the calling user.
 <P>MemWrite operations are guaranteed to be atomic.
 <P>If the entire target area is protected from other user access(i.e. all
 overlaying sections are locked by the writing user),then the atomic write
 operation is executed in its most efficient form, without the need for explicit
 protection by MemSys.
 <P>If however, any part of the targeted area is not protected from other user
 access (i.e. one or more of the overlaying sections are not locked by the
 calling user), then the atomic nature of the write operation is explicitly
 enforced by MemSys.
 <P>MemWrite() is given the potential to block by setting <I>BlockOpt</I>
 appropriately. The operation will block if any bytes of the target area are not
 writeable by the calling user.
 <P>A MemWrite() operation completes when the complete target memory area
 becomes writeable by the caller. This is usually accomplished by another user's
 calling MemUnlock() or MemSecPriv() regarding the un-writeable section(s)
 underlying the target area.
 <P>See the Using Blocking <I>XIPC</I> Functions Appendix for a description of
 how to use the blocking options.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Mid</CODE> - The memory segment ID of the segment to be
                   written. <I>Mid</I> was obtained by the user via MemCreate()
                   or MemAccess() method calls.<DD><CODE>Offset</CODE> - The number of bytes beyond the start of the
                   segment from where the MemWrite operation should commence.<DD><CODE>Length</CODE> - The number of bytes to be written from
                   <I>Buffer</I> to the MemSys segment starting at <I>Offset</I>
                   bytes into the segment.<DD><CODE>Buffer</CODE> - A pointer to a source data buffer or a call to
                   the MEM_FILL() macro. MEM_FILL() when specified, is used for
                   filling each byte of the targeted memory area with a specific
                   byte value. MEM_FILL() takes the desired byte fill value as
                   its argument.<DD><CODE>BlockOpt</CODE> - One of MEM_WAIT, MEM_NOWAIT or MEM_TIMEOUT(t)
                   for an integer t. See <A
                   HREF="XipcBlockingOption.html">blocking option parameter</A>
                   for further information.<DT><B>Returns:</B><DD><dd>RC>=0 - MemWrite successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADBLOCKOPT - Invalid <I>BlockOpt</I>
                   <dd>XipcErr.MEM_ER_BADBUFFER - <I>Buffer</I> is NULL.
                   <dd>XipcErr.MEM_ER_BADMID - Invalid Memory Segment ID
                   <I>Mid</I>.
                   <dd>XipcErr.MEM_ER_BADOPTION - Invalid <I>Options</I><B>
                   </B>parameter.
                   <dd>XipcErr.MEM_ER_BADTARGET - Invalid target specification.
                   <dd>XipcErr.MEM_ER_CAPACITY - MemSys internal system capacity
                   error.
                   <dd>XipcErr.MEM_ER_DESTROYED - Another user destroyed the
                   memory segment targeted by the blocked MemWrite operation.
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in
                   the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.MEM_ER_NOWAIT - <I>BlockOpt</I> of MEM_NOWAIT
                   specified and request was not immediately satisfied.
                   <dd>XipcErr.MEM_ER_TIMEOUT - The blocked MemWrite() operation
                   timed out.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <dd>XipcErr.XIPCNET_ER_TOOBIG - Text exceed instance's size
                   limit.
                   <p><dt><b>Example:</b>
                   <dd>See MemRead <A HREF="#MemRead Example">example</A> for
                   example of usage of MemWrite.</DL>
</DD>
</DL>
<HR>

<A NAME="MemWrite(int, int, int, byte, int)"><!-- --></A><H3>
MemWrite</H3>
<PRE>
public final int <B>MemWrite</B>(int&nbsp;Mid,
                          int&nbsp;Offset,
                          int&nbsp;Length,
                          byte&nbsp;fillbyte,
                          int&nbsp;BlockOpt)</PRE>
<DL>
<DD>Fill part of a memory segment with a given byte value.
 MemWrite() attempts to fill the memory segment identified by <I>Mid</I>,
 starting at <I>Offset</I> bytes from the start of the segment, with the value
 of <I>fillbyte</I>.
 <P>The MemWrite operation will succeed if and only if all the bytes targeted by
 the operation are currently writeable by the calling user.
 <P>MemWrite operations are guaranteed to be atomic.
 <P>If the entire target area is protected from other user access(i.e. all
 overlaying sections are locked by the writing user),then the atomic write
 operation is executed in its most efficient form, without the need for explicit
 protection by MemSys.
 <P>If however, any part of the targeted area is not protected from other user
 access (i.e. one or more of the overlaying sections are not locked by the
 calling user), then the atomic nature of the write operation is explicitly
 enforced by MemSys.
 <P>MemWrite() is given the potential to block by setting <I>BlockOpt</I>
 appropriately. The operation will block if any bytes of the target area are not
 writeable by the calling user.
 <P>A MemWrite() operation completes when the complete target memory area
 becomes writeable by the caller. This is usually accomplished by another user's
 calling MemUnlock() or MemSecPriv() regarding the un-writeable section(s)
 underlying the target area.
 <P>See the Using Blocking <I>XIPC</I> Functions Appendix for a description of
 how to use the blocking options.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Mid</CODE> - The memory segment ID of the segment to be
                   written. <I>Mid</I> was obtained by the user via MemCreate()
                   or MemAccess() method calls.<DD><CODE>Offset</CODE> - The number of bytes beyond the start of the
                   segment from where the MemWrite operation should commence.<DD><CODE>Length</CODE> - The number of bytes to be written from
                   <I>Buffer</I> to the MemSys segment starting at <I>Offset</I>
                   bytes into the segment.<DD><CODE>fillbyte</CODE> - Used for filling each byte of the targeted
                   memory area with a specific byte value.<DD><CODE>BlockOpt</CODE> - One of MEM_WAIT, MEM_NOWAIT or MEM_TIMEOUT(t)
                   for an integer t. See <A
                   HREF="XipcBlockingOption.html">blocking option parameter</A>
                   for further information.<DT><B>Returns:</B><DD><dd>RC>=0 - MemWrite successful.
                   <dd>RC<0 - Error (see error codes below).
                   <dt> <b>Error Codes:</b>
                   <dd>XipcErr.MEM_ER_BADBLOCKOPT - Invalid <I>BlockOpt.</I>
                   <dd>XipcErr.MEM_ER_BADMID - Invalid Memory Segment ID
                   <I>Mid</I>.
                   <dd>XipcErr.MEM_ER_BADOPTION - Invalid <I>Options</I><B>
                   </B>parameter.
                   <dd>XipcErr.MEM_ER_BADTARGET - Invalid target specification.
                   <dd>XipcErr.MEM_ER_CAPACITY - MemSys internal system capacity
                   error.
                   <dd>XipcErr.MEM_ER_DESTROYED - Another user destroyed the
                   memory segment targeted by the blocked MemWrite operation.
                   <dd>XipcErr.MEM_ER_NOSUBSYSTEM - MemSys is not configured in
                   the instance.
                   <dd>XipcErr.MEM_ER_NOTLOGGEDIN - User not logged into
                   instance (User never logged in, was aborted or disconnected).
                   <dd>XipcErr.MEM_ER_NOWAIT - <I>BlockOpt</I> of MEM_NOWAIT
                   specified and request was not immediately satisfied.
                   <dd>XipcErr.MEM_ER_TIMEOUT - The blocked MemWrite() operation
                   timed out.
                   <dd>XipcErr.XIPCNET_ER_CONNECTLOST - Connection to instance
                   lost.
                   <dd>XipcErr.XIPCNET_ER_NETERR - Network transmission error.
                   <p><dt><b>Example:</b>
                   <dd><pre>
                   Xipc connection = new Xipc();
                   int uid = connection.XipcLogin("@server:NetInstance",
                   "user");
                   int mid = connection.MemCreate("segment1",4096);
                   MidList ml =
                   Xipc.MemListBuild(Xipc.MemSectionBuild(mid,0,4096));
                   int retcode = connection.MemLock(Xipc.MEM_ANY, ml, null,
                   Xipc.MEM_WAIT);
                   retcode = connection.MemWrite(mid, 0, 4096, 0xFF,
                   Xipc.MEM_WAIT);
                   </pre>
                   After logging in, a memory segment of size 4096 bytes is
                   created, and a MidList is created containing a section
                   overlaying the entire segment.
                   MemLock is used to lock the section, and MemWrite is used to
                   fill it with the hexadecimal value FF.</DL>
</DD>
</DL>
<HR>

<A NAME="MemSectionBuild(int, int, int)"><!-- --></A><H3>
MemSectionBuild</H3>
<PRE>
public static final <A HREF="../javaxipc30/Section.html">Section</A> <B>MemSectionBuild</B>(int&nbsp;Mid,
                                            int&nbsp;Offset,
                                            int&nbsp;Size)</PRE>
<DL>
<DD>Create a new Section object.
 <p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>Mid</CODE> - The memory segment ID of the section. <I>Mid</I>
                   was obtained by the user via MemCreate() or MemAccess()
                   method calls.<DD><CODE>Offset</CODE> - The number of bytes beyond the start of the
                   segment from where the section starts.<DD><CODE>Size</CODE> - The size of the memory section. The size is
                   specified in units of bytes.<DT><B>Returns:</B><DD>A new Section object.
                   <p><dt><b>Example:</b>
                   <dd>See MemListBuild <A HREF="#MemRead Example">example</A>
                   for an example of usage of MemSectionBuild</A>.
                   <p><DT><B>See Also: </B><DD><A HREF="../javaxipc30/Section.html"><CODE>Section</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Xipc.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../javaxipc30/XintRef.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../javaxipc30/XipcErr.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Xipc.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
